<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java泛型5——泛型通配符</title>
      <link href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li>Java泛型1——概述</li><li>Java泛型2——泛型类</li><li>Java泛型3——泛型接口</li><li>Java泛型4——泛型方法</li><li>Java泛型5——泛型通配符</li><li>Java泛型6——类型擦除</li></ul><h2 id="什么是通配符"><a href="#什么是通配符" class="headerlink" title="什么是通配符"></a>什么是通配符</h2><p>在Java中，类与类之间是有继承关系的。例如，<code>Integer</code> 类继承自 <code>Number</code> 类，因此<code>Integer</code> 类的对象可以赋值给 <code>Number</code> 类的引用（即<strong>向上转型</strong>，这是可以实现<strong>多态性</strong>的一个重要因素）。但集合之间没有这种关系，也就是 <code>LinkedList&lt;Integer&gt;</code> 和  <code>LinkedList&lt;Number&gt;</code>之间并没有继承关系，<strong>它们都是<code>LinkedList</code> 类</strong>。因此  <code>LinkedList&lt;Number&gt;</code> 的集合并不能存放<code>Integer</code> 类型的变量（虽然<code>Integer</code> 类继承自 <code>Number</code> 类）。</p><p>比如下面这段代码：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;Father&gt; test) &#123;        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; tesF = new Test&lt;&gt;();        Test&lt;Child&gt; testC = new Test&lt;&gt;();        Main.dealTest(tesF);        Main.dealTest(testC);//编译器报错    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>这段代码定义了一个泛型类 <code>Test</code> ，并定义了一个处理该类的静态方法 <code>dealTest()</code>，该类接受一个 <code>Test&lt;Father&gt;</code> 对象作为参数。根据上面的介绍可以知道，虽然<code>Child</code> 是  <code>Father</code> 的子类，但<code>Test&lt;Child&gt;</code> 和 <code>Test&lt;Father&gt;</code> 之间并没有继承关系，因此静态方法 <code>dealTest()</code>不能接受一个 <code>Test&lt;Son&gt;</code> 对象。因此，若想让静态方法 <code>dealTest()</code>处理<code>Test&lt;Son&gt;</code> 对象，还需对其进行重载：</p><pre><code class="java">private static void dealTest(Test&lt;Child&gt; test) &#123;    &#125;</code></pre><p>但这显然违背了多态性的设计理念，而且<strong>这是编译器不允许的做法</strong>。如果能让 <code>dealTest()</code>方法不只接受<code>Test&lt;Father&gt;</code>对象，而是让其接受<code>Test&lt;XXX&gt;</code>对象，其中<strong>XXX代表某一类型内的类型参数</strong>，那么上面这个问题就可以解决了。</p><p>这就是泛型通配符的作用：<strong>泛型通配符用于限制类型参数的范围。</strong></p><p>泛型通配符有 3 种形式：</p><ul><li><?> ：无界通配符</li><li><? extends T> ：有上界的通配符</li><li><? super T> ：有下界的通配符</li></ul><h2 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h2><p>无界通配符：**&lt;?&gt;**，其中 <strong>?</strong> 代表了任意一种数据类型。比如，下面这段代码：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;?&gt; test) &#123;//?代表可以使用任意一种数据类型        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; tesF = new Test&lt;&gt;();        Test&lt;Child&gt; testC = new Test&lt;&gt;();        Test&lt;Integer&gt; testI = new Test&lt;&gt;();        Main.dealTest(tesF);        Main.dealTest(testC);        Main.dealTest(testI);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>由于使用了无界通配符，<code>dealTest()</code>方法可以接受具有不同泛型参数的泛型类 <code>Test</code>的对象。</p><p>需要注意：</p><ul><li><p>不要混淆 <code>Test&lt;Object&gt;</code>  和  <code>Test&lt;?&gt;</code> ，<code>Object</code> 也是一种数据类型，因此 <strong><code>Test&lt;Object&gt;</code> 代表参数类型只能为<code>Object</code>的<code>Test</code>类</strong>， <code>Test&lt;?&gt;</code>代表参数类型可以是任意数据类型的<code>Test</code>类</p></li><li><p><strong>最后不要在实例化泛型类的时候使用无界通配符</strong>，<code>&lt;?&gt;</code> 集合的数据类型是不确定的，因此我们只能往集合中添加<code>null</code>，而且从其中取出的元素也只能赋值给<code>Object</code>对象。</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;?&gt; list = new LinkedList&lt;&gt;();        list.add(null);        list.add(1);//编译器报错，只能放入null    &#125;&#125;</code></pre></li></ul><h2 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h2><p>上界通配符：**&lt;? extends T&gt;<strong>，其中</strong>T** 代表了类型参数的上界。上界通配符将类型参数限制为特定类型<strong>T</strong>及其子类型。比如，<code>&lt;? extends Number&gt;</code>表示类型参数可以是<code>Number</code>以及<code>Number</code>的子类。</p><p>可以使用上界通配符对上面的代码进行改写：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;? extends Father&gt; test) &#123;//&lt;? extends Father&gt; 代表可以使用 Father 及其子类作为类型参数        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; fatherTest = new Test&lt;&gt;();        Test&lt;Child&gt; childTest = new Test&lt;&gt;();        Main.dealTest(fatherTest);        Main.dealTest(childTest);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>以 <code>LinkedList&lt;? extends Number&gt;</code> 为例，在使用上界通配符的时候需要注意：</p><p> <code>LinkedList&lt;? extends Number&gt;</code> 可以代表 <code>LinkedList&lt;? extends Interger&gt;</code>、 <code>LinkedList&lt;? extends Double&gt;</code>……但是，不能指定 <code>LinkedList&lt;? extends Number&gt;</code>的数据类型。如下：</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;? extends Number&gt; list1 = new LinkedList&lt;Integer&gt;();//编译正确        LinkedList&lt;? extends Number&gt; list2 = new LinkedList&lt;Double&gt;();//编译正确        LinkedList&lt;? extends Number&gt; list3 = new LinkedList&lt;Object&gt;();//编译器报错，超出上界        LinkedList&lt;Number&gt; list4 = new LinkedList&lt;Integer&gt;();//编译器报错        list1.add(1);//编译器报错        list1.add(2.3);//编译器报错        list1.add(null);//编译正确    &#125;&#125;</code></pre><p>在看上面的代码之前，需要明确一个概念，那就是 <strong><code>LinkedList&lt;? extends Number&gt;</code>表示这个集合可能是 <code>LinkedList&lt;? extends Interger&gt;</code>也可能是 <code>LinkedList&lt;? extends Double&gt;</code>，但它什么都可能是的后果就是它什么也不是，也就是说不能确定它到底是 <code>LinkedList&lt;? extends Interger&gt;</code>还是 <code>LinkedList&lt;? extends Double&gt;</code>或者其他什么集合</strong>，所以也就<strong>不能往里面添加具体类型的元素</strong>，因为不能确定它是什么类型的。但和无界通配符类似，**可以往里面添加<code>null</code>**。</p><h2 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h2><p>下界通配符：**&lt;? super T&gt;<strong>，与上界通配符刚好相反，T代表了类型参数的下界。类似地，下界通配符将类型参数限制为特定类型</strong>T**及其超类。比如，<code>&lt;? extends Integer&gt;</code>表示类型参数可以是<code>Integer</code>以及<code>Integer</code>的超类。</p><p>可以使用下界通配符对上面的代码进行改写：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;? super Child&gt; test) &#123;//&lt;? super Child&gt; 代表可以使用 Child 及其超类作为类型参数        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; fatherTest = new Test&lt;&gt;();        Test&lt;Child&gt; childTest = new Test&lt;&gt;();        Main.dealTest(fatherTest);        Main.dealTest(childTest);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>带有上界统配符的集合<code>LinkedList&lt;? extends Number&gt;</code>不能添加具体类型的元素，但是<strong>带有下界通配符的集合<code>LinkedList&lt;? super Number&gt;</code>可以添加<code>Number</code>类及其子类的对象，但是不能添加<code>Number</code>类的父类对象</strong>。因为<code>LinkedList&lt;? extends Number&gt;</code>最低也是个<code>LinkedList&lt;Number extends Number&gt;</code>集合，因此至少也能存放<code>Number</code>类对象，所以也可以存放<code>Number</code>子类对象。但是<code>LinkedList&lt;? extends Number&gt;</code>的上限不知道，所以类似于带有上界通配符的集合不能存放具体的数据类型，<code>LinkedList&lt;? extends Number&gt;</code>也不能存放<code>Number</code>父类的对象。</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;? super Number&gt; list1 = new LinkedList&lt;Object&gt;();//编译正确        LinkedList&lt;? super Number&gt; list2 = new LinkedList&lt;Integer&gt;();//编译器报错，超出下界        list1.add(1);//编译正确        list1.add((Object) 2.5);//编译器报错，不能存放 Number 类的父类对象    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型4——泛型方法</title>
      <link href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li>Java泛型1——概述</li><li>Java泛型2——泛型类</li><li>Java泛型3——泛型接口</li><li>Java泛型4——泛型方法</li><li>Java泛型5——泛型擦除</li><li>Java泛型6——通配符</li></ul><h2 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h2><p>泛型方法的定义格式如下：</p><pre><code class="java">&lt;泛型标记符1, 泛型标记符2……&gt; 返回类型 方法名(泛型标记符1 变量名1, 泛型标记符2 变量名2……) &#123;&#125;</code></pre><h3 id="泛型标记符出现了两次"><a href="#泛型标记符出现了两次" class="headerlink" title="泛型标记符出现了两次"></a>泛型标记符出现了两次</h3><p>一次在&lt;&gt;中，一次在()中，其中：</p><blockquote><ul><li>&lt;&gt;中指明在接下来的函数参数列表中可以使用的泛型标记符</li><li>()中是函数参数，可以出现的类型有：<ul><li>8种基本数据类型</li><li>&lt;&gt;中的泛型标记符</li><li>定义泛型类（如果这个方法在一个泛型类中）时的泛型标记符</li></ul></li></ul></blockquote><p>比如下面代码：</p><pre><code class="java">class TestClass&lt;T&gt; &#123;    public &lt;U, V&gt; void f(int a, T b, U c) &#123;    &#125;&#125;</code></pre><p>泛型方法 <code>f()</code> 共有3个参数，包括：</p><ul><li><p>1个基本数据类型a，在<strong>定义函数</strong>的时候就指明是int类型的了</p></li><li><p>1个泛型参数类型b，在<strong>实例化对象</strong>的时候才能确定T代表的数据类型（T是定义泛型类时使用的泛型参数）</p></li><li><p>1个泛型参数类型c，在<strong>调用函数</strong>的时候才能确定U代表的数据类型（U是定义泛型方法时使用的泛型参数）</p></li></ul><p>上面泛型方法在定义的时候<strong>提供了两个泛型参数即U和V</strong>，但实际在参数列表中<strong>只使用了一个U</strong>，虽然这种写法很神经，但这种写法在语法上没问题。</p><h3 id="注意泛型方法和使用泛型类中的类型参数的方法"><a href="#注意泛型方法和使用泛型类中的类型参数的方法" class="headerlink" title="注意泛型方法和使用泛型类中的类型参数的方法"></a>注意泛型方法和使用泛型类中的类型参数的方法</h3><pre><code class="java">class TestClass&lt;T&gt; &#123;    void f_1(T t) &#123;//这只是使用了定义泛型类时的类型参数，不是泛型方法        System.out.println(&quot;这不是泛型方法&quot;);    &#125;    public &lt;U&gt; void f_2(U u) &#123;//这才是泛型方法        System.out.println(&quot;这才是泛型方法&quot;);    &#125;&#125;</code></pre><ul><li>定义泛型方法：函数签名的返回值前面加了<code>&lt;&gt;</code></li><li>使用泛型类中的类型参数：函数签名中仅有参数中使用了定义类时的类型参数</li></ul><h3 id="泛型方法的几种定义方式"><a href="#泛型方法的几种定义方式" class="headerlink" title="泛型方法的几种定义方式"></a>泛型方法的几种定义方式</h3><pre><code class="java">class TestClass&lt;T&gt; &#123;    public void f_1(T t) &#123;//这只是使用了定义泛型类时的类型参数，不是泛型方法        System.out.println(&quot;这不是泛型方法&quot;);    &#125;        public &lt;U&gt; void f_2(U u) &#123;//这才是泛型方法        System.out.println(&quot;这才是泛型方法&quot;);    &#125;        public static &lt;U&gt; void f_3(U u) &#123;//静态泛型方法        System.out.println(&quot;静态泛型方法&quot;);    &#125;        public &lt;U, V&gt; void f_4(U u, V v) &#123;//同时使用多个类型参数        System.out.println(&quot;使用多个类型参数&quot;);    &#125;        public &lt;U&gt; void f_5(U u, T t) &#123;//使用了定义泛型类时的类型参数        System.out.println(&quot;使用了定义泛型类时的类型参数&quot;);    &#125;&#125;</code></pre><h3 id="泛型方法重载"><a href="#泛型方法重载" class="headerlink" title="泛型方法重载"></a>泛型方法重载</h3><p>对泛型方法重载时，只可以通过参数数目进行重载，如：</p><pre><code class="java">class TestClass &#123;    public &lt;T&gt; void f_1(T t) &#123;    &#125;    public &lt;U&gt; void f_1(U u) &#123;//类型参数数目相同，编译报错    &#125;    public &lt;T&gt; void f_1(T t1, T t2) &#123;//类型参数数目不同，方法重载    &#125;&#125;</code></pre><p><code>public &lt;T&gt; void f_1(T t)</code> 和 <code>public &lt;U&gt; void f_1(U u)</code> 仅仅是使用的类型参数名字不同（一个是T一个是U），无法区分两个方法。</p><h3 id="泛型方法和可变长参数"><a href="#泛型方法和可变长参数" class="headerlink" title="泛型方法和可变长参数"></a>泛型方法和可变长参数</h3><pre><code class="java">class TestClass &#123;    public &lt;T&gt; void f_1(T... args) &#123;        for (T t : args) &#123;            System.out.println(t);        &#125;    &#125;&#125;</code></pre><h2 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h2><p>显式调用泛型方法的格式如下：</p><pre><code class="java">对象名(或类名，如果是静态方法).&lt;数据类型1, 数据类型2……&gt;方法名(参数1, 参数2……)</code></pre><p>同时，泛型方法也支持非显式调用。实例化泛型类或者实现泛型接口时需要指定类型参数（否则自动设置为Object），但<strong>在调用泛型方法时，通常不需要指定参数类型</strong>，编译器会根据传入参数的数据类型自动判断出类型参数所代表的具体数据类型，这被称为<strong>类型参数推断</strong>。对于基本类型，编译器还可以根据变量类型进行<strong>自动装箱</strong>（将基本类型自动转换成它们对应的包装类，将包装类自动转换成它们对应的基本类型称为<strong>自动拆箱</strong>）。</p><h3 id="一个类型参数"><a href="#一个类型参数" class="headerlink" title="一个类型参数"></a>一个类型参数</h3><pre><code class="java">public class Main &#123;    private static &lt;T&gt; void f(T t) &#123;        System.out.println(t);    &#125;    public static void main(String[] args) &#123;        Main.f(1);//自动装箱成 Integer        Main.&lt;Integer&gt;f(1);//与上面等价        Main.f(&#39;a&#39;);//自动装箱成 Character        Main.&lt;Character&gt;f(&#39;a&#39;);        Main.f(&quot;abc&quot;);//字符串是一个String类型的对象，不是基本类型，不进行自动装箱        Main.&lt;String&gt;f(&quot;abc&quot;);    &#125;&#125;</code></pre><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><ul><li><p>显式调用的时候根据指定的参数类型设置</p></li><li><p>非显式调用的时候会进行类型推断，若参数的类型相同则设置为相同的类型，否则将类型参数设置为<strong>所有传入参数最小的共同父类</strong>，比如：</p><ul><li>1 和 2 取  Integer</li><li>1.2 和 3 取 Number</li><li>1 和 “abc” 取 Object</li></ul><pre><code class="java">public class Main &#123;    private static &lt;T, U&gt; void f(T t, U u) &#123;        System.out.println(t);    &#125;    public static void main(String[] args) &#123;        Main.f(1, 2);//自动装箱为 Integer 和 Integer        Main.&lt;Integer, Integer&gt;f(1, 2);//与上面等价，参数类型相同取相同的        Main.f(1.2, 3);//自动装箱为 Double 和 Integer        Main.&lt;Number, Number&gt;f(1.2, 3);//与上面等价，设置为 Double 和 Integer 的最小共同父类 Number        Main.f(1, &quot;abc&quot;);//1自动装箱为 Integer        Main.&lt;Object, Object&gt;f(1, &quot;abc&quot;);//与上面等价，设置为 Integer 和 String 的最小共同父类 Object    &#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型3——泛型接口</title>
      <link href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><p>Java泛型1——概述</p></li><li><p>Java泛型2——泛型类</p></li><li><p>Java泛型3——泛型接口</p></li><li><p>Java泛型4——泛型方法</p></li><li><p>Java泛型5——泛型擦除</p></li><li><p>Java泛型6——通配符</p></li></ul><h2 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h2><p>类似泛型类的定义，泛型接口的定义格式如下：</p><pre><code class="java">interface 接口名 &lt;泛型标记符1, 泛型标记符2……&gt; &#123;&#125;</code></pre><p>比如，下面这个泛型接口：</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    T t;//编译时报错，接口中的变量会被隐式的指定为 public static final 变量        static void f(T t)&#123;//编译时报错，静态方法不能使用定义泛型接口时使用的泛型标记符            &#125;    public abstract void print(T t);&#125;</code></pre><p>泛型接口中的变量会被隐式的指定为 public static final 变量，因此<strong>泛型接口中的变量不可以使用定义泛型接口时使用的泛型标记符</strong>。同样，<strong>接口中的静态方法（Java8开始，接口里可以使用静态方法）也不能使用定义泛型接口时使用的泛型标记符</strong>。</p><h2 id="实现泛型接口"><a href="#实现泛型接口" class="headerlink" title="实现泛型接口"></a>实现泛型接口</h2><p>泛型类也可以继承，任何一个泛型类都可以作为父类或子类。不过泛型类在继承时需要注意以下几点：</p><ol><li><p>类是泛型类，</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    public abstract void print(T t);&#125;//类中与接口同名的泛型标记符可以传递给接口//类的泛型标记符包含接口的泛型标记符class TestClass_1&lt;T&gt; implements TestInterface&lt;T&gt; &#123;    @Override    public void print(T t) &#123;        System.out.println(t);    &#125;&#125;class TestClass_2&lt;T, U, V, W&gt; implements TestInterface&lt;T&gt; &#123;    @Override    public void print(T t) &#123;        System.out.println(t);    &#125;&#125;//类的泛型标记符不包含接口中的泛型标记符class TestClass_3&lt;U, V, W&gt; implements TestInterface&lt;String &gt; &#123;//指明接口泛型参数的数据类型    @Override    public void print(String s) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成String    &#125;&#125;class TestClass_4&lt;U, V, W&gt; implements TestInterface&#123;//未指明接口泛型参数的数据类型，则默认接口泛型参数是Object    @Override    public void print(Object o) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成Object    &#125;&#125;</code></pre></li><li><p>类不是泛型类</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    public abstract void print(T t);&#125;class TestClass_5 implements TestInterface&lt;String&gt; &#123;//指明接口泛型参数的数据类型    @Override    public void print(String s) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成String    &#125;&#125;class TestClass_6 implements TestInterface &#123;//未指明接口泛型参数的数据类型，则默认接口泛型参数是Object    @Override    public void print(Object o) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成Object    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型2——泛型类</title>
      <link href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB/"/>
      <url>/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><p><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></p></li><li><p>Java泛型2——泛型类</p></li><li><p>Java泛型3——泛型接口</p></li><li><p>Java泛型4——泛型方法</p></li><li><p>Java泛型5——泛型擦除</p></li><li><p>Java泛型6——通配符</p></li></ul><h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><p>Java定义泛型类与定义非泛型类的方法类似，只是需要自类名后面添加<strong>类型参数</strong>。<strong>类型参数用尖括号括住，放在类名后面，泛型类接受多个类型参数，参数间用逗号隔开</strong>。具体的定义格式如下：</p><pre><code class="java">class 类名 &lt;泛型标记符1, 泛型标记符2……&gt; &#123;    private 泛型标记符1 t1;    private 泛型标记符2 t2;        private void setT1(泛型标记符1 t1) &#123;        this.t1 = t1;    &#125;    ……&#125;</code></pre><p>其中，泛型标记符相当于一个<strong>类型占位符</strong>，提示这里需要一个类型参数并暂时使用泛型标记符表示，具体是哪种类型需要等实际使用也就是实例化对象的时候才能确定。</p><p>泛型标记符是可以任意设置的，但为了方便阅读代码，建议遵循以下规范：</p><blockquote><ul><li><p>T：任意的Java类</p></li><li><p>E：集合中的元素</p></li><li><p>K：键值对中的键</p></li><li><p>V：键值对中的值</p></li><li><p>N：数值类型</p></li></ul></blockquote><p>比如，下面这个泛型类：</p><pre><code class="java">class Test&lt;T, SetItAnyWill&gt; &#123;    private T a;//成员变量a的数据类型为 T ，T 代表的具体类型在实例化时指定    private SetItAnyWill b;//成员变量b的数据类型为 SetItAnyWill ，SetItAnyWill 代表的具体类型在实例化时指定    public void setA(T aValue) &#123;        this.a = aValue;    &#125;    public void setB(SetItAnyWill bValue) &#123;        this.b = bValue;    &#125;    public T getA() &#123;        return this.a;    &#125;    public SetItAnyWill getB() &#123;        return this.b;    &#125;&#125;</code></pre><p>这个泛型类包含两个泛型标记符，分别叫做 <code>T</code> 和 <code>SetItAnyWill</code> （之所以取这个名字，只是想再展示一下泛型标记符可以任意设置），至于 <code>T</code> 和 <code>SetItAnyWill</code> 具体代表的是什么类型，只有实例化这个类时（见下面“使用泛型类”）才会确定下来。</p><p>注意，<strong>泛型类中静态变量和静态方法不可以使用定义泛型类时使用的泛型标记符</strong>（静态变量和静态方法在类加载时已经初始化，而此时泛型类的类型参数还未指定，因此不能使用泛型类的泛型标记符），但静态方法可以在定义时使用新的泛型标记符（此时，静态方法成为泛型方法）。如：</p><pre><code class="java">class Test&lt;T, SetItAnyWill&gt; &#123;    static T staticA;//编译时报错，静态变量不允许使用定义泛型类时用的泛型标记符    static void setStaticA(T staticAValue) &#123;//编译时报错，静态方法不允许使用定义泛型类时用的泛型标记符    &#125;    static &lt;N&gt; void print(N number)&#123;//静态方法可以在定义时使用新的泛型标记符，泛型标记符在定义泛型类时未使用过        System.out.println(number);    &#125;&#125;</code></pre><p><em>泛型方法如何定义和使用后面会有具体的介绍。</em></p><h2 id="使用泛型类"><a href="#使用泛型类" class="headerlink" title="使用泛型类"></a>使用泛型类</h2><p>有两种实例化一个泛型类的对象的格式，一种是Java5开始使用的语法，一种是从Java7开始使用的简写语法，如下：</p><pre><code class="java">类名&lt;数据类型1, 数据类型2……&gt; 对象名 = new 类名&lt;&gt;();//Java7开始使用的简写语法类名&lt;数据类型1, 数据类型2……&gt; 对象名 = new 类名&lt;数据类型1, 数据类型2……&gt;();//Java5使用的语法</code></pre><p>比如：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        Test&lt;String, Integer&gt; test = new Test&lt;&gt;(); //T 被替换为 Sting，SetItAnyWill 被替换为 Integer        test.setA(&quot;this is string&quot;);        test.setB(10);        //test.setA(20);//编译报错，对于 test 来说 setA()方法需要传入一个字符串        //test.setB(&quot;this is string&quot;);//编译报错，对于 test 来说 setB()方法需要传入一个整形变量                Test&lt;Integer, Character&gt; another = new Test&lt;&gt;(); //T 被替换为 Integer，SetItAnyWill 被替换为 Character        another.setA(30);        another.setB(&#39;a&#39;);        //another.setA(true);//编译报错，对于 another 来说 setA()方法需要传入一个整形变量        //another.setB(&quot;cde&quot;);//编译报错，对于 another 来说 setA()方法需要传入一个字符    &#125;&#125;</code></pre><p>为了便于理解，当使用<code>Test&lt;String, Integer&gt; test = new Test&lt;&gt;();</code>实例化一个泛型类后，我们可以认为编译器会将上面定义的泛型类根据&lt;&gt;中传入的数据类型进行泛型标记符替换（<strong>仅仅是便于理解，实际不是这样的</strong>），替换后的代码如下：</p><pre><code class="java">//泛型标记符 T 被替换为 String//泛型标记符 SetItAnyWill 被替换为 Integerclass Test&#123;    private String a;    private Integer b;    public void setA(String aValue) &#123;        this.a = aValue;    &#125;    public void setB(int bValue) &#123;        this.b = bValue;    &#125;    public String getA() &#123;        return this.a;    &#125;    public Integer getB() &#123;        return this.b;    &#125;&#125;</code></pre><p>在使用泛型类时需要注意以下几点：</p><blockquote><ul><li><p>传入的类型参数需要和定义泛型类时的数目保持一致</p></li><li><p>可以不传入类型参数，此时默认传入的是Object类，比如：</p></li></ul><p><code>Test test1 = new Test();//不传入类型参数</code></p><p>这相当于：</p><p><code>Test&lt;Object, Object&gt; test1 = new Test&lt;&gt;();</code></p><ul><li><p>类型参数只能是引用类型，不能是基本类型</p></li><li><p>Java有8种基本类型，这8种类型在使用泛型类时不能作为类型参数传入，只能使用对应的封装类型</p></li><li><p>基本类型及其对应的封装类：</p><table><thead><tr><th>基本类型</th><th>封装类</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>Integer</td><td>32</td><td>-2^31 ~ 2^31-1</td><td>0</td><td>整型</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>-2^15 ~ 2^15-1</td><td>0</td><td>短整型</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>-2^63 ~ 2^63-1</td><td>0</td><td>长整型</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>-2^128 ~ 2^128</td><td>0.0f或0.0F</td><td>单精度浮点型</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>-2^1024 ~ 2^1024</td><td>0</td><td>双精度浮点型，默认的小数类型</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>‘\u0000’ ~ ‘\uFFFF’</td><td>‘\u0000’</td><td>字符型，Unicode编码</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td>true 或 false</td><td>false</td><td>布尔型</td></tr><tr><td>byte</td><td>Byte</td><td>8</td><td>-2^7 ~ 2^7-1</td><td>0</td><td>字符型，数据在内存中的最原始状态</td></tr></tbody></table></li></ul></blockquote><h2 id="泛型类的继承"><a href="#泛型类的继承" class="headerlink" title="泛型类的继承"></a>泛型类的继承</h2><p>泛型类也可以继承，任何一个泛型类都可以作为父类或子类。不过泛型类在继承时需要注意以下几点：</p><ol><li><p>子类是泛型类，</p><pre><code class="java">class Father&lt;T&gt; &#123;&#125;//子类中与父类同名的泛型标记符可以传递给父类//子类的泛型标记符包含父类的泛型标记符class Child_1&lt;T&gt; extends Father&lt;T&gt; &#123;&#125;class Child_2&lt;T, U, V, W&gt; extends Father&lt;T&gt; &#123;&#125;//子类的泛型标记符不包含父类的泛型标记符class Child_3&lt;U, V, W&gt; extends Father&lt;String&gt;&#123;//指明父类泛型参数的数据类型&#125;class Child_4&lt;U, V, W&gt;extends Father&#123;//未指明父类泛型参数的数据类型，则默认父类泛型参数是Object&#125;</code></pre></li><li><p>子类不是泛型类</p><pre><code class="java">class Father&lt;T&gt; &#123;&#125;class Child_5 extends Father&lt;String&gt;&#123;//指明父类泛型参数的数据类型&#125;class Child_6 extends Father&#123;//未指明父类泛型参数的数据类型，则默认父类泛型参数是Object&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型1——概述</title>
      <link href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><p>Java泛型1——概述</p></li><li><p><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></p></li><li><p><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></p></li><li><p>Java泛型4——泛型方法</p></li><li><p>Java泛型5——泛型擦除</p></li><li><p>Java泛型6——通配符</p></li></ul><h2 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h2><p>泛型，即<strong>类型参数</strong>，类似于函数中的参数，泛型可以将<strong>类型参数化</strong>。这句话过于抽象，为了便于解释，下面根据个人理解将泛型与函数中的参数做个对比。</p><p>从简单的人手，首先说一下函数参数经历的两个阶段：</p><ul><li><p>函数定义</p><p>在定义函数时，只知道参数的类型而不知道具体的值（此时的参数叫做形参）。此时，为了定义函数在参数上的操作，我们需要给参数取个名字，比如下面这个函数：</p><pre><code class="java">private void testF(int a, int b) &#123;    System.out.println(a);    System.out.println(b);&#125;</code></pre><p>在这个函数定义中，只知道有两个 <code>int</code> 类型的参数且名字分别叫a、b，但具体的值此时尚不知道。</p></li><li><p>函数调用</p><p>在调用函数时，我们需要按照函数的要求传入两个<code>int</code>类型的变量：</p><pre><code class="java">//调用函数testF(1. 2);</code></pre></li></ul><p>从上面可以看出来，对于函数参数而言：<strong>函数在定义时知道参数的类型和名字，但不知道具体的值，在函数调用时才知道具体的值是多少</strong>。而泛型更进一步，以泛型方法为例，<strong>在定义一个泛型方法时，仅仅知道参数的名字，而参数的类型和具体的值只有在调用函数的时候才能确定！</strong></p><p>另外，与函数参数不同的是，类、接口、函数中都可以加入泛型机制，即为类、接口、函数指定类型参数，分别被叫做<strong>泛型类、泛型接口、泛型函数</strong>。</p><h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><p>根据<a href="https://www.ituring.com.cn/book/2935">《On Java 8》</a>的描述：“<strong>泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足</strong>”。</p><p>Talk is cheap,let me show you the code，假设我们现在有个很简单的需求：需要<strong>用一个集合存放String类型的变量，并将这个集合中的内容打印输出</strong>。使用泛型可以这样写:</p><h3 id="通过泛型实现"><a href="#通过泛型实现" class="headerlink" title="通过泛型实现"></a>通过泛型实现</h3><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;String&gt; stringList = new LinkedList&lt;&gt;(); //&lt;String&gt; 是一个泛型                stringList.add(&quot;abc&quot;);        stringList.add(&quot;def&quot;);        //stringList.add(1); //当添加一个非 String 类型的变量时，编译器会报错                for (int i = 0; i &lt; stringList.size(); i++) &#123;            System.out.println(stringList.get(i));        &#125;    &#125;&#125;</code></pre><p>在上面的代码中：</p><ol><li><code>&lt;String&gt;</code>是一个泛型，它限制了<code>stringList</code>中只能存放<code>String</code>类型的变量（约定集合要存储什么类型的对象）</li><li><code>stringList.add(1);</code>，由于泛型的存在，当<code>stringList</code>试图添加一个非String类型的变量时，编译器会报错（通过编译器确保规约（也就是只能存放String类型变量）得以满足）</li></ol><p>第一点实际展示了如何使用泛型，这再后面还会再详细介绍，先具体说一下第二点：如何理解<strong>通过编译器确保规约得以满足</strong>？在Java中，<strong>Object类是所有类的超类</strong>，通过向下转型，下面这段代码可以实现和上面类似的功能：</p><h3 id="通过Object和转型实现"><a href="#通过Object和转型实现" class="headerlink" title="通过Object和转型实现"></a>通过Object和转型实现</h3><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList stringList = new LinkedList(); //未使用泛型机制，此时可以放入任何类型的变量        stringList.add(&quot;abc&quot;);        stringList.add(&quot;def&quot;);        stringList.add(1); //可以添加非 String 类型的变量，编译器不会报错        for (int i = 0; i &lt; stringList.size(); i++) &#123;            System.out.println((String) stringList.get(i));        &#125;    &#125;&#125;</code></pre><p>上面这段代码在定义<code>stringList</code>时未使用泛型机制，因此可以添加任意类型的变量，即使添加的变量类型不同<strong>编译器也不会报错</strong>。但！！！在执行代码时会出现错误：</p><p><img src="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/1.jpg" alt="1"></p><p>这个错误是由于我们错误的将<code>Integer</code> 类型强制转换为<code>String</code>类型而引起的。</p><p>当然，这个报错我们可以通过<strong>反射机制</strong>避免，但这种错误处理方式太过繁琐，而且会大大降低代码的复用性（若通过泛型，可以很轻松的将功能改为存放并输出<code>Integer</code>类型对象，而使用泛型则需要添加新的判断逻辑）。</p><p>另外，我们不能寄希望于其他人（甚至自己）会一直按照规定调用代码。因此，最好的方式就是<strong>尽可能的在程序编译阶段就将问题暴露出来</strong>，而不是等用户真正使用产品的时候再去修改本不该出现的bug。而泛型就有这个能力：<strong>通过编译器确保规约得以满足</strong>！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇博客里，简单概述了一下泛型，接下来将分几篇博客分别介绍泛型类、泛型接口、泛型方法等，随着使用的逐渐深入，对泛型将会有更多的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透</title>
      <link href="/2023/07/26/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2023/07/26/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>放假回家需要远程实验室的电脑，虽然可以通过Windows自带的远程功能加VPN访问，但有时电脑会重启，开机后电脑IP地址也就变了。为了确保万无一失，设置了内网穿透，实现通过公网IP访问内网机器的功能。</p><h2 id="frp介绍"><a href="#frp介绍" class="headerlink" title="frp介绍"></a>frp介绍</h2><p>frp是一个开源的内网穿透工具，支持TCP、UDP、HTTP、HTTPS等协议，可以将内网的机器安全、便捷的通过具有公网IP的机器暴露到公网中。<strong>（太过抽象，可以跳过这一部分，直接进入准备工作，配置好之后再回来看就会明白了）</strong></p><ul><li><p>frp项目地址：<a href="https://github.com/fatedier/frp">frp</a></p></li><li><p>frp工作原理</p><p>frp需要一台具有公网IP地址的机器作为服务端，内网中的机器作为客户端。frp包括两部分，frps以及frpc，服务端运行frps，客户端运行frpc，其工作原理如下：</p><ul><li>服务端运行frps，对设置的<strong>主端口</strong>进行监听，等待客户端的连接</li><li>客户端运行frpc，连接到服务端，同时告诉服务端<strong>要监听的端口</strong>和<strong>转发类型</strong></li><li>服务端开启新的进程监听客户端指定的端口</li><li>公网用户连接到服务端的端口（该端口是第二步中客户端指定的端口），服务端将数据转发到客户端</li></ul></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里我的服务端是一台Linux服务器，客户端是一台Windows电脑。</p><ol><li><p>下载frp：<a href="https://github.com/fatedier/frp/releases">frp下载地址</a></p><p>需要根据对应的操作系统和CPU架构，分别在服务端和客户端下载对应的frp。</p></li><li><p>解压frp</p><p>下载解压之后，服务器端保留<strong>frps、frps.ini、LICENSE</strong>这三个文件，电脑保留<strong>frpc、frpc.ini、LICENSE</strong>这三个文件即可。</p></li><li><p>Linux以及Windows需设置防火墙开放对应的端口，根据下面的配置，Linux需开启7000（该端口用于服务端与客户端之间建立联系）以及9000端口（该端口用于公网用户连接内网Windows），Windows需开启3389端口（该端口用于远程桌面）。</p></li></ol><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><h3 id="frps配置"><a href="#frps配置" class="headerlink" title="frps配置"></a>frps配置</h3><p>打开 <code>frps.ini</code> 文件，输入以下内容：</p><pre><code class="shell">[common]bind_port = 7000 # 主端口，可设置为其他端口，客户端将通过该端口与服务端建立通信token = thisispassword # 用于身份验证</code></pre><h3 id="启动frps"><a href="#启动frps" class="headerlink" title="启动frps"></a>启动frps</h3><p>在解压后的文件夹内输入以下内容：</p><pre><code class="shell">./frps -c ./frps.ini</code></pre><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>经过以上设置，frps已经在服务器上启动并监听7000端口了，但服务器重启后需要手动启动frps，因此这里再设置一下frps开机自启。</p><ol><li><p>在**&#x2F;lib&#x2F;systemd&#x2F;system** 下面新建一个文件<strong>frps.service</strong>:</p><pre><code class="shell">vim /lib/systemd/system/frps.service</code></pre></li><li><p>写入以下内容</p><pre><code class="shell">[Unit]Description=frps[Service]Type=simpleExecStart=frps所在文件夹/frps -c frps所在文件夹/frps.ini[Install]WantedBy=multi-user.target</code></pre></li><li><p>启动</p><pre><code class="shell">systemctl start frps</code></pre></li><li><p>设置开机自启</p><pre><code class="shell">systemctl enable frps</code></pre></li></ol><h2 id="电脑端"><a href="#电脑端" class="headerlink" title="电脑端"></a>电脑端</h2><h3 id="frpc配置"><a href="#frpc配置" class="headerlink" title="frpc配置"></a>frpc配置</h3><p>打开frpc.ini文件，输入以下内容：</p><pre><code class="shell">[common]server_addr = 服务器的公网IP地址server_port = 7000 # frps.ini里面设置的主端口token = thisispassword # 与frps.ini里面设置的保持一致[RDP]type = tcplocal_ip = 127.0.0.1local_port = 3389 # 本地需要映射到服务器上的端口remote_port = 9000 # 映射到服务器上的端口</code></pre><h3 id="启动frpc"><a href="#启动frpc" class="headerlink" title="启动frpc"></a>启动frpc</h3><p>在 <code>frpc.ini</code> 所在的文件夹进入命令行窗口，输入：</p><pre><code class="shell">./frpc -c ./frpc.ini</code></pre><p>启动成功后：</p><blockquote><ol><li>服务器端的7000端口将监听到有个frpc客户端想要与服务器建立连接</li><li>服务器端根据客户端的设置开始监听9000端口</li><li>若此时有台电脑<strong>访问服务器的9000端口</strong>，则根据frp的映射，将实际访问客户端的3389端口也就<strong>是访问Windows电脑的远程</strong></li></ol></blockquote><h3 id="设置开机自启桌面"><a href="#设置开机自启桌面" class="headerlink" title="设置开机自启桌面"></a>设置开机自启桌面</h3><p>同样，为了避免手动启动的麻烦，frpc也需要设置开机自启。借助winsw设置Windows下frpc的开机自启：</p><ol><li><p>根据需要<a href="https://github.com/winsw/winsw/releases">下载winsw-*.exe</a></p></li><li><p>将下载的 <code>winsw-*.exe</code> 放到 <code>frpc</code> 所在的文件夹</p></li><li><p>新建一个名为 <code>winsw.xml</code> 的文件，写入以下内容：</p><pre><code class="xml">&lt;service&gt;    &lt;id&gt;frp&lt;/id&gt;    &lt;name&gt;frp&lt;/name&gt;    &lt;description&gt;frp&lt;/description&gt;    &lt;executable&gt;frpc&lt;/executable&gt;    &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt;    &lt;logmode&gt;reset&lt;/logmode&gt;&lt;/service&gt;</code></pre></li><li><p>管理员权限打开命令行窗口，进入到 <code>frpc</code> 所在的文件夹，输入以下内容</p><pre><code class="shell">winsw install</code></pre></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>frp还提供了后台管理等功能，具体可参考<a href="https://gofrp.org/docs/">frp文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 百宝箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百宝箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器3——Map</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/</url>
      
        <content type="html"><![CDATA[<p>以下内容参考《<a href="https://www.programmercarl.com/other/kstar_baguwen.html">代码随想录知识星球精华（最强⼋股⽂）第三版</a>》整理。</p><h2 id="Map继承关系图"><a href="#Map继承关系图" class="headerlink" title="Map继承关系图"></a>Map继承关系图</h2><p>（该图基于JDK8，仅包含部分类。为了方便查看，部分关系未画出）</p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/Map.jpg" alt="Map继承关系"></p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/Map%E6%8E%A5%E5%8F%A3.jpg" alt="Map接口"></p><ul><li>Map是⼀组键值对，键不可重复，值可重复</li><li>常⽤的实现类有：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器2——Collection</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/</url>
      
        <content type="html"><![CDATA[<p>以下内容参考《<a href="https://www.programmercarl.com/other/kstar_baguwen.html">代码随想录知识星球精华（最强⼋股⽂）第三版</a>》整理。</p><h2 id="Collection继承关系图"><a href="#Collection继承关系图" class="headerlink" title="Collection继承关系图"></a>Collection继承关系图</h2><p>（该图基于JDK8，仅包含部分类。为了方便查看，部分关系未画出）</p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Collection.jpg" alt="Collection继承关系"></p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Collection%E6%8E%A5%E5%8F%A3.jpg" alt="Collection接口"></p><ul><li>Collection下的所有实现类都是继承⾃AbstractCollection，该类将基础⽅法 size 和 iterator 抽象化，但是实现了其他的⽅法</li><li>AbstractCollection下派⽣出AbstractList、AbstractSet、AbstractQueue、ArrayQueue</li><li>List下的全部继承⾃AbstractList，List是一个存储有序的集合，允许重复，每个元素都有一个索引</li><li>Set下的继承⾃AbstractSet，Set是一个无需存储的集合，不允许重复</li></ul><p><strong>Java中经常使⽤的语法糖”for each”循环可以与任何实现了Iterable接⼝的对象⼀起⼯作</strong>。<br>Collection通过调用iterator()⽅法返回⼀个Iterator对象，这就是常⽤的迭代器，其中包含hasNext()、next()、remove()、forEachRemaining(Consumer)4个⽅法。</p><p>Iterator()的功能简单，只能单向移动：</p><ol><li>调⽤iterator()⽅法返回⼀个Iterator对象</li><li>第⼀次调⽤Iterator的next()⽅法，返回序列的第⼀个元素。此后每调⽤⼀个next(),会返回序列的下⼀个元素。调⽤next()⽅法前最好先调⽤hasNext()⽅法，判断序列后⾯是否还有元素</li><li>remove()删除上次next()返回的对象，remove()只能在next()之后使⽤，并且⼀个remove()匹配⼀个next()，不能重复调⽤</li><li>使⽤hasNext()判断序列中是否还有元素</li></ol><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/List%E6%8E%A5%E5%8F%A3.jpg" alt="List接口"></p><ul><li>List接⼝常⽤的实现类有<strong>ArrayList、LinkedList</strong></li><li>相比Collection，List多出sort()、get()、listIterator()等⽅法，listIterator返回⼀个链表迭代器</li></ul><p>List有着特殊的迭代器接口ListIterator，该接口继承自Iterator接⼝。ListIterator是⼀个功能更加强⼤的迭代器，Iterator是单向的，但ListIterator是双向的，ListIterator增加了previous()和hasPrevious()⽅法⽤来反向遍历。<strong>注意只能List使⽤ListIterator。</strong></p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/ListIterator.jpg" alt="ListIterator"></p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Set%E6%8E%A5%E5%8F%A3.jpg" alt="Set接口"></p><ul><li>Set常⽤的实现类有<strong>HashSet、TreeSet、LinkedHashSet</strong></li></ul><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Queue%E6%8E%A5%E5%8F%A3.jpg" alt="Queur接口"></p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Deque.jpg" alt="Deque"></p><ul><li>Deque接⼝继承⾃Queue,在Deque的基础上更加细化，可以选择从头部或者尾部操作。如果Deque中使⽤Queue的⽅法，⼀定要清楚实现类是从头部还是尾部操作的</li><li><strong>很多实现类既实现类List接⼝，⼜实现类Queue接⼝</strong>，如<strong>LinkedList即实现了List接口又实现了Deque接口（因此LinkedList即可以使用add又可以使用addLast）</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器1——概述</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A81%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A81%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Java容器主要分为两大类：</p><ul><li>Collection：一个独立元素的序列，一次存一个元素，是单列集合。Collection又主要包括以下三种：<ul><li>List：存储的元素有序、可重复，是个常用的容器</li><li>Set：存储的元素无序、不可重复，用于数据需要唯一存在的场景</li><li>Queue：存储的元素有序、可重复，可指定存取数据的先后顺序</li></ul></li><li>Map：一组成对的“键值对”对象，一次存一对元素，是双列集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA Diagrams的使用</title>
      <link href="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近打算整理一下Java的容器类，需要画出容器类的UML类图。找了一下画UML的软件，感觉都不太满意，正好发现IDEA自带的类图分析插件Diagrams可以画类图，而且使用体验还不错。（<strong>IDEA社区版不支持该功能</strong>）</p><h2 id="设置Diagrams"><a href="#设置Diagrams" class="headerlink" title="设置Diagrams"></a>设置Diagrams</h2><ol><li><p>打开设置界面：<code>File-&gt;Settings</code></p></li><li><p>确保启用Diagrams：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/1.jpg" alt="1"></p></li><li><p>设置Diagrams：<code>Tools-&gt;Diagrams</code>，在这里可以根据需要对Diagrams做具体的设置，因为我只想看一下类之间的继承关系，所以只对继承做了设置。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/2.jpg" alt="3"></p></li></ol><h2 id="使用Diagrams"><a href="#使用Diagrams" class="headerlink" title="使用Diagrams"></a>使用Diagrams</h2><h3 id="打开Diagrams"><a href="#打开Diagrams" class="headerlink" title="打开Diagrams"></a>打开Diagrams</h3><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/3.jpg" alt="3">   </p><p>有两种方式可以打开Diagrams，一种是在代码区直接右键选择Diagrams，另一种是在文件的目录树中进入。这里我选择第二种方式，以 <code>LinkedList</code> 为例，在 <code>LinkedList</code> 的文件上右键选择Diagrams，此时有两种选择：</p><ul><li>Show Diagram…：将在代码区新建一个窗口</li><li>Show Diagram Popup…：在当前桌面直接弹出一个缩略图</li></ul><p>这里我选择方法一新建一个窗口，下图中：</p><ul><li><font color='green'>绿色的‘I’是接口</font>，<font color='blue'>蓝色的‘C’是类</font></li><li><font color='green'>绿色虚线是类与接口之间的实现关系</font></li><li><font color='green'>绿色实线是接口之间的继承关系</font></li><li><font color='blue'>蓝色实线是类之间的继承关系</font></li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/4.gif" alt="4"></p><h3 id="增删类"><a href="#增删类" class="headerlink" title="增删类"></a>增删类</h3><ul><li>添加类：<code>右键-&gt;Content-&gt;Add Class to Diagram</code>（或者在界面中直接按空格）</li><li>删除类：<code>选中类-&gt;右键-&gt;Delete</code>（或者选中类然后按下键盘的Del键）</li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/add_del.gif" alt="add_del"></p><h3 id="缩放、拖动界面"><a href="#缩放、拖动界面" class="headerlink" title="缩放、拖动界面"></a>缩放、拖动界面</h3><p>按住 <code>Ctrl</code> 键然后滚动<code>鼠标滚轮</code>可以实现缩放当前界面，按住<code>鼠标右键</code>然后拖动鼠标可以移动当前界面，按住 <code>Alt键</code> 出现放大镜。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/5.gif" alt="5"></p><h3 id="Diagrams工具栏介绍"><a href="#Diagrams工具栏介绍" class="headerlink" title="Diagrams工具栏介绍"></a>Diagrams工具栏介绍</h3><p>这里我将工具栏大致分为以下4部分，下面分别介绍：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/6.jpg" alt="6"></p><ol><li><p>第一部分：</p><p>从左到右点击将依次显示：字段、构造函数、成员函数、属性（具有get和set方法）、内部类。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/7.gif" alt="7"></p></li><li><p>第二部分：</p><p>从左到右依次是：显示依赖关系、更改排序、更改可见级别（如只显示public等）、改变显示范围（如项目文件、非项目文件等）、在节点元素之间创建扩展或实现链接。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/8.gif" alt="8"></p></li><li><p>第三部分：</p><p>从左到右依次是：放大、缩小、恢复实际大小、自动适应当前窗口大小。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/9.gif" alt="9"></p></li><li><p>第四部分：</p><p>使用右键快捷菜单“布局”选项中选择的当前布局、缩放到窗口的边缘（类似自动布线？）、复制当前界面到剪切板、单击后鼠标选定的区域将被复制到剪切板、导出Diagrams、刷新当前界面、打开Diagrams设置页面、在浏览器中打开帮助页面。</p></li></ol><h3 id="右键快捷菜单介绍"><a href="#右键快捷菜单介绍" class="headerlink" title="右键快捷菜单介绍"></a>右键快捷菜单介绍</h3><p>选中一个元素然后单击右键将出现以下快捷菜单：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/10.jpg" alt="10"></p><p>不选择任何元素直接在界面单击右键将出现以下快捷菜单：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/11.jpg" alt="11"></p><p>部分功能已经在上面介绍过了，这里仅介绍部分常用的功能，其他功能可参考<a href="https://www.jetbrains.com/help/idea/2023.1/class-diagram-toolbar-and-context-menu.html#menu">帮助文档</a>：</p><ul><li>Selected Element Actions -&gt; Jump to Source：打开该类的源码</li><li>Show Implementations：显示该类的实现和继承</li><li>Show Parents：显示该类实现或继承谁</li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/12.gif" alt="12"></p><h2 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h2><p>在IntelliJ IDEA的<code>Settings-&gt;Plugins</code>中还可以安装其他的UML类图插件，比如可以安装diagrams，支持直接在IntelliJ IDEA画流程图。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> IDEA技巧 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git同时配置Gitee和GitHub</title>
      <link href="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/"/>
      <url>/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/</url>
      
        <content type="html"><![CDATA[<p>注意，以下基本都在 <code>~/.ssh</code> 目录下以及在这个目录下打开的Git Bash窗口中操作，因此打开 <code>~/.ssh</code> 目录及Git Bash窗口后，暂时不要关闭！</p><h2 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a>配置Git用户名和邮箱</h2><p>首先，为Git设置用户名和邮箱。（若已设置过，则无需设置）</p><pre><code class="shell">git config --global user.name 用户名git config --global user.email 邮箱</code></pre><h2 id="生成SSH-keys"><a href="#生成SSH-keys" class="headerlink" title="生成SSH keys"></a>生成SSH keys</h2><p>许多Git托管网站（如Gitee和GitHub）都使用SSH协议进行认证，因此为了向Gitee和GitHub提供SSH公钥，必须事先为其生成一份SSH密钥对。这个过程在所有操作系统上都是相似的：</p><ol><li><p>进入存放密钥对的文件夹，SSH密钥对存放在 <code>~/.ssh</code> 目录下。在Windows系统下，安装键盘的 <code>Windows</code> 键和 <code>R</code> 键输入 <code>.ssh</code> 回车即可打开</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/1.jpg" alt="1"></p></li><li><p>生成SSH keys</p><p>在<code>~/.ssh</code> 目录下进入Git Bash，输入下列命令然后一直回车即可：</p><pre><code class="shell">ssh-keygen -t rsa -f id_rsa.gitee -C &quot;gitee&quot;ssh-keygen -t rsa -f id_rsa.github -C &quot;github&quot;</code></pre><p>参数含义：</p><ul><li>-t：指定密钥类型，默认是 rsa ，可以省略</li><li>rsa：指使用RSA算法</li><li>-f：指定存储密钥的文件名</li><li>-C：设置注释文字</li></ul><p>若生成成功，则出现</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/2.jpg" alt="2"></p><p>同时，在刚才的 <code>.ssh</code> 文件夹下，将会生成4个新文件：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/3.jpg" alt="3"></p><p>其中：</p><ul><li>id_rsa.xx：私钥</li><li>id_rsa_xx.xx.pub：私钥对应的公钥</li></ul></li></ol><h2 id="添加私钥到ssh-agent中"><a href="#添加私钥到ssh-agent中" class="headerlink" title="添加私钥到ssh-agent中"></a>添加私钥到ssh-agent中</h2><p>Git默认读取的文件文件名为id_rsa，因此我们需要将生成的密钥添加到ssh-agent中。在刚才打开的Git Bash窗口中输入：</p><pre><code class="shell">ssh-agent bashssh-add ~/.ssh/id_rsa.giteessh-add ~/.ssh/id_rsa.github</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>~/.ssh</code> 目录下打开 <code>config</code> 文件，若没有则新建一个名为 <code>config</code> 的文件（<strong>注意，这个文件不带扩展名，全面就叫做config</strong>），然后添加以下内容：</p><blockquote><p>#Gitee<br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>User git<br>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa.gitee</p><p>#GitHub<br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>User git<br>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa.github</p></blockquote><h2 id="添加公钥到托管网站"><a href="#添加公钥到托管网站" class="headerlink" title="添加公钥到托管网站"></a>添加公钥到托管网站</h2><ol><li><p>Gitee添加公钥</p><p>登录Gitee，进入 <code>设置</code> ，点击 <code>SSH公钥</code> ，输入“标题”以及“公钥”。Gitee对应的公钥存放在 <code>id_rsa.gitee.pub</code> 文件中，打开全部复制即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/4.jpg" alt="4"></p></li><li><p>GitHub添加公钥</p><p>登录GitHub，进入 <code>Settings</code> ，依次点击 <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code> ，输入“Title”以及“Key”。GitHub对应的公钥存放在 <code>id_rsa.github.pub</code> 文件中，打开全部复制即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/5.jpg" alt="5"></p></li></ol><h2 id="测试是否添加成功"><a href="#测试是否添加成功" class="headerlink" title="测试是否添加成功"></a>测试是否添加成功</h2><p>依次在Git Bash中输入：</p><pre><code class="shell">ssh -T git@gitee.com # 测试Giteessh -T git@github.com # 测试GitHub</code></pre><p>第一次连接会让输入 <code>yes/no</code> ，输入 <code>yes</code> 即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/6.jpg" alt="6"></p><p>出现下面即代表添加成功：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/7.jpg" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Git技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对使用Git、GitHub时邮箱和用户名的理解</title>
      <link href="/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在使用Git以及GitHub时会多次用到“邮箱”和“用户名”，这里记录一下它们的区别。</p><h2 id="登录GitHub时"><a href="#登录GitHub时" class="headerlink" title="登录GitHub时"></a>登录GitHub时</h2><p><img src="/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/1.jpg" alt="1"></p><p>这里的用户名或邮箱是<strong>用于登录GitHub</strong>这个网站的。</p><h2 id="配置Git时"><a href="#配置Git时" class="headerlink" title="配置Git时"></a>配置Git时</h2><pre><code class="shell">git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;</code></pre><p>这两条命令是配置 Git 的全局用户名和邮箱，在进行版本控制时用于记录用户身份信息。Git在commit信息中会显示提交人及其邮箱地址，方便追踪提交记录。因此这里的邮箱和用户名是<strong>为了回溯是谁提交的代码</strong>，并不需要一定填写GitHub的用户名和邮箱，甚至是可以随便填写的用户名和邮箱（当然，极其不建议这样做）。</p><p>在使用GitHub时，可能会发现一个bug：虽然提交了commit，但是主页却不显示contributions。这个bug很可能就是在Git配置的邮箱地址与GitHub中的邮箱地址不符合造成的。</p><ul><li>如果本地设定的user.email值与GitHub上的账户的邮件地址相同，GitHub会认定推送代码的操作是账户拥有者自己做的，跟直接登录到GitHub，从网站上修改，是相同的。此时，修改人是一样，就是账户拥有者。</li><li>如果本地设定的user.email值与GitHub不同，也能把代码推送到GitHub（只要密码或者ssh正确），GitHub会记录这次的修改是另一个人做的。</li></ul><h2 id="设置SSH-Key时"><a href="#设置SSH-Key时" class="headerlink" title="设置SSH Key时"></a>设置SSH Key时</h2><p>GitHub通过HTTPS协议（密码）或者SSH验证身份。其中：</p><ul><li>HTTPS协议只认账号。如果使用HTTPS操作远程仓库，则需要使用账号密码来做权限的认证。</li><li>SSH协议只认机器。当使用SSH操作远程仓库的话，需要使用公钥和私钥对来做权限的认证。</li></ul><p>为了方便操作，一般都是使用SSH协议，当使用SSH协议时，需要在本地电脑上生成公钥和私钥对，然后在GitHub上配置公钥。公钥和私钥对使用如下指令生成：</p><pre><code class="shell">ssh-keygen -t rsa -f id_rsa.github -C &quot;XXX&quot;</code></pre><p>其中：</p><ul><li>-t：指定密钥的类型，密钥的类型有RSA和DSA两种</li><li>rsa：指使用RSA算法</li><li>-f：指定存储密钥的文件名</li><li>-C：表示提供<strong>一个用于识别这个密钥的注释，一般填写邮箱地址，但也可以填入其他内容</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>Git配置邮箱和用户名的目的</p><p>作为一个分布式版本控制系统，远程仓库为了跟踪是谁提交的代码，需要提交这提供身份信息：邮箱和用户名。当然，由于这里的用户名和邮箱完全由提交者设置，所以可能会出现提交者随意填写的情况发生。不过，当这种情况发生时，可以通过一些机制查询出真正的提交者。</p></li><li><p>Git配置的邮箱和用户名和GitHub有什么关系</p><ul><li>账号密码和公钥私钥对只做权限的认证，即判断当前用户或机器是否可以向GitHub中的仓库推送代码。但是这两种认证方式不会记录是由谁把代码推送到GitHub中的，所以使用Git在本地配置的邮箱和用户名作为标记用于记录是谁做的推送操作。即：<ul><li>账号密码和公钥私钥对用于认证，即打开GitHub的大门</li><li>Git配置的邮箱和用户名用于记录是谁向GitHub推送的代码，即记录下是谁在GitHub中做的操作</li></ul></li></ul></li><li><p>Git和GitHub可不可以配置不同的邮箱和用户名</p><p>可以，但最好还是配置相同的邮箱和用户名。正如上面所说，只有这样，GitHub中才能正确的记录你的操作。另外：</p><ul><li>如果Git配置的邮箱是GitHub中存在的邮箱，则commits里显示的是这个邮箱对应的账号</li><li>如果Git配置的邮箱是一个在GitHub里不存在的邮箱，则commits里显示的是Git配置的用户名</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Git技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch中nn.XXX与F.XXX的区别</title>
      <link href="/2023/07/12/PyTorch%E4%B8%ADnn-XXX%E4%B8%8EF-XXX%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/07/12/PyTorch%E4%B8%ADnn-XXX%E4%B8%8EF-XXX%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="nn-XXX与F-XXX"><a href="#nn-XXX与F-XXX" class="headerlink" title="nn.XXX与F.XXX"></a>nn.XXX与F.XXX</h2><p>PyTorch中torch.nn<strong>（以下简写为nn）</strong>中的模块和torch.nn.functional<strong>（以下简写为F）</strong>中的模块都提供了常用的神经网络操作，包括激活函数、损失函数、池化操作等。它们的主要区别如下：</p><ul><li>nn中的模块是以类形式存在的；F中的模块是以函数形式存在的</li><li>nn中的模块是nn.Module的子类，包含可学习参数、可导，在反向传播中可以计算梯度，可以在模型中作为子模块使用；F中的模块是纯函数，没有与之相关联的可学习参数，虽然也可以用于反向传播，但是其梯度需要手动计算</li><li>nn中的模块需要实例化后，将张量作为实例的调用参数；F中的模块直接传递张量作为参数</li><li>nn中的模块可以管理和访问模块的内部参数和状态；F中的函数是纯函数，没有与之相关联的参数或状态，因此无法直接管理和访问函数的内部状态</li></ul><h2 id="nn-Relu与F-relu"><a href="#nn-Relu与F-relu" class="headerlink" title="nn.Relu与F.relu()"></a>nn.Relu与F.relu()</h2><p>以激活函数ReLu为例，在使用激活函数时，有以下两种方式可以使用：</p><pre><code class="python"># 方法一nn.ReLU()# 方法二F.relu(input)</code></pre><p>这两种方法都是使用ReLu激活，但使用的场景不一样。</p><ul><li><p>nn.ReLU是一个类，必须实例化后才能使用，一般在<strong>定义网络层</strong>的时候使用</p><pre><code class="python"># nn.ReLU的常用方法nn.Sequential(            nn.Conv2d(in_channels, out_channels),            nn.ReLU(inplace=True)        )</code></pre></li><li><p>F.relu()是函数调用，一般使用在<strong>foreward()函数</strong>中</p></li><li><p>nn.ReLU只能处理Variable类型的张量；而F.relu()可以处理Tensor和Variable类型的张量</p></li><li><p>nn.ReLU需要额外占用内存用来存储中间结果；而F.relu()则是直接在原张量上进行操作，不需要额外的内存占用</p></li></ul><p>另外：</p><ul><li>当用print()打印输出神经网络时，会输出nn.ReLU()层，而F.relu()是没有输出的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch搭建神经网络</title>
      <link href="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>PyTorch版本：1.12.1</li><li><a href="https://pytorch.org/docs/stable/index.html">PyTorch官方文档</a></li><li><a href="https://pytorch.apachecn.org/#/">PyTorch中文文档</a></li></ul><p>PyTorch中搭建并训练一个神经网络分为以下几步：</p><ol><li>定义神经网络</li><li>定义损失函数以及优化器</li><li>训练：反向传播、梯度下降</li></ol><p>下面以LeNet-5为例，搭建一个卷积神经网络用于手写数字识别。</p><h2 id="1-模型简介——LeNet-5"><a href="#1-模型简介——LeNet-5" class="headerlink" title="1. 模型简介——LeNet-5"></a>1. 模型简介——LeNet-5</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/726791">LeNet-5</a>是一个经典的深度卷积神经网络，由Yann LeCun在1998年提出用于解决手写数字识别问题。该网络是第一个被广泛应用于数字图像识别的神经网络之一，也是深度学习领域的里程碑之一，被认为是卷积神经网络的起源之一。</p><p>如下图所示，LeNet-5的结构是一个7层的卷积神经网络（不含输入层），其中包括2个卷积层、2个下采样层（池化层）、2个全连接层以及输出层。</p><p><img src="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.jpg" alt="1"></p><h3 id="1-1-输入层（Input-layer"><a href="#1-1-输入层（Input-layer" class="headerlink" title="1.1 输入层（Input layer)"></a>1.1 输入层（Input layer)</h3><p>输入层接收大小为 32*32 的灰度手写数字图像，像素灰度值范围为0-255。为了加快训练速度以及提高模型准确性，通常会对输入图像的像素值进行归一化。</p><h3 id="1-2卷积层C1（Convolutional-layer-C1）"><a href="#1-2卷积层C1（Convolutional-layer-C1）" class="headerlink" title="1.2卷积层C1（Convolutional layer C1）"></a>1.2卷积层C1（Convolutional layer C1）</h3><p>卷积层C1含有6个卷积核，每个卷积核的大小为 5*5 ，步长为1，填充为0。卷积层C1产生6个大小为 28*28 的特征图。</p><h3 id="1-3-下采样层S2（Subsampling-layer-S2）"><a href="#1-3-下采样层S2（Subsampling-layer-S2）" class="headerlink" title="1.3 下采样层S2（Subsampling layer S2）"></a>1.3 下采样层S2（Subsampling layer S2）</h3><p>采样层S2采用最大池化（max-pooling）操作，这可以减少特征图的大小从而提高计算效率，并且池化操作对于轻微的位置变化可以保持一定的不变性。池化层每个窗口的大小为 2*2 ，步长为2。池化层S2产生6个大小为 14*14 的特征图。</p><h3 id="1-4-卷积层C3（Convolutional-layer-C3）"><a href="#1-4-卷积层C3（Convolutional-layer-C3）" class="headerlink" title="1.4 卷积层C3（Convolutional layer C3）"></a>1.4 卷积层C3（Convolutional layer C3）</h3><p>卷积层C3包括16个卷积核，每个卷积核的大小为 5*5 ，步长为1，填充为0。卷积层C1产生16个大小为 10*10的特征图。</p><h3 id="1-5-下采样层S4（Subsampling-layer-S4）"><a href="#1-5-下采样层S4（Subsampling-layer-S4）" class="headerlink" title="1.5 下采样层S4（Subsampling layer S4）"></a>1.5 下采样层S4（Subsampling layer S4）</h3><p>下采样层S4采用最大池化操作，每个窗口的大小为 2*2 ，步长为2。池化层S4产生16个大小为 5*5 的特征图。</p><h3 id="1-6-全连接层C5（Fully-connected-layer-C5）"><a href="#1-6-全连接层C5（Fully-connected-layer-C5）" class="headerlink" title="1.6 全连接层C5（Fully connected layer C5）"></a>1.6 全连接层C5（Fully connected layer C5）</h3><p>C5将16个大小为 5*5 的特征图拉成一个长度为400的向量，并通过一个包括120个神经元的全连接层。120是由LeNet-5的设计者根据实验得到的最佳值。</p><h3 id="1-7-全连接层F6（Fully-connected-layer-F6）"><a href="#1-7-全连接层F6（Fully-connected-layer-F6）" class="headerlink" title="1.7 全连接层F6（Fully connected layer F6）"></a>1.7 全连接层F6（Fully connected layer F6）</h3><p>全连接层F6将120个神经元连接到84个神经元。</p><h3 id="1-8-输出层（Output-layer）"><a href="#1-8-输出层（Output-layer）" class="headerlink" title="1.8 输出层（Output layer）"></a>1.8 输出层（Output layer）</h3><p>输出层由10个神经元组成，每个神经元对应0-9的激活值（激活值越大，是该数字的可能性越大）。模型训练时，使用交叉熵损失函数计算输出层与样本真实标签之间的误差，然后通过反向传播算法更新模型的参数（包括卷积核和全连接层）直至模型达到指定效果或者达到指定迭代次数。</p><p><strong>在实际应用中，通常会对LeNet-5进行一些改进，例如增加网络深度、增加卷积核数量、添加正则化等方法，以进一步提高模型的准确性和泛化能力。</strong></p><h2 id="2-数据集简介——MNIST"><a href="#2-数据集简介——MNIST" class="headerlink" title="2. 数据集简介——MNIST"></a>2. 数据集简介——MNIST</h2><p><a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>是一个手写体数字的图片数据集，包含60,000个训练图像和10,000个测试图像，由美国国家标准与技术研究所（National Institute of Standards and Technology (NIST)）发起整理，一共统计了来自250个不同的人手写数字图片，其中50%是高中生，50%来自人口普查局的工作人员。<strong>数据集中的图像都是灰度图像，大小为 28*28 像素，每个像素点的值为 0 到 255 之间的灰度值</strong>。</p><p>使用torchvision中的datasets可自动下载该数据集：</p><pre><code class="python">train_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=True, transform=transforms.ToTensor(), download=True)test_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=False, transform=transforms.ToTensor(), download=True)</code></pre><p>其中：</p><ul><li><p>root表示将数据集存放在当前目录下的’data’文件夹中。</p></li><li><p>train&#x3D;True表示导入的是训练数据；train&#x3D;False表示导入的是测试数据。</p></li><li><p>transform表示对每个数据进行的变化，这里是将其变为Tensor，Tensor是PyTorch中存储数据的主要格式。</p></li><li><p>download表示是否将数据下载到本地。</p></li></ul><h2 id="3-定义神经网络"><a href="#3-定义神经网络" class="headerlink" title="3. 定义神经网络"></a>3. 定义神经网络</h2><p>PyTorch中主要有以下两种方式定义神经网络</p><h3 id="3-1-使用前馈神经网络方式"><a href="#3-1-使用前馈神经网络方式" class="headerlink" title="3.1 使用前馈神经网络方式"></a>3.1 使用前馈神经网络方式</h3><p>这种方法需要<strong>继承torch.nn.Module</strong>并且<strong>实现__init__()和forward()这两个方法</strong>。其中__init__()可以用于做一些初始化工作，比如定义输入数据、隐藏层、激活函数等；forward()是实现前向传播的核心函数，用于定义神经网络的结构和参数，在前向传播的过程中，输入的数据将按照该函数定义的神经网络结构进行计算并得到最终的输出。</p><pre><code class="python">import torch.nn.functional as Ffrom torch import nnclass my_CNN(nn.Module):    def __init__(self, in_channels):        super(my_CNN, self).__init__()        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1)  # 定义卷积核        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # 定义最大池化层        self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(in_features=16 * 4 * 4, out_features=120)  # 定义全连接层        self.fc2 = nn.Linear(in_features=120, out_features=84)        self.fc3 = nn.Linear(in_features=84, out_features=10)    def forward(self, x):        x1 = self.conv1(x)  # 卷积层C1        x2 = F.relu(x1)  # 激活函数        x3 = self.pool1(x2)  # 下采样层S2        x4 = self.conv2(x3)  # 卷积层C3        x5 = F.relu(x4)        x6 = self.pool2(x5)  # 下采样层S4        x7 = x.reshape(x6.shape[0], -1)  # 二维变成一维，以输入到全连接层        x8 = self.fc1(x7)  # 全连接层C5        x9 = F.relu(x8)        x10 = self.fc2(x9)  # 全连接层F6        x11 = F.relu(x10)        x12 = self.fc3(x11)  # 输出层        return x12</code></pre><p>代码解释</p><ul><li><p>__init__()：</p><p>定义了用到的卷积核、池化层以及全连接层，其中：</p><ul><li>nn.Conv2d，定义二维卷积核。in_channels，输入通道数量；out_channels，输出通道数量；kernel_size，卷积核大小；stride，卷积时的步长。</li><li>nn.MaxPool2d，定义二维最大池化层。kernel_size，池化的窗口大小；stride，池化时的步长。</li><li>nn.Linear，定义全连接层。in_features，输入数据的大小；out_features，输出数据的大小。</li></ul></li><li><p>forward()：</p><p>__init__()函数中仅仅是定义了各个层，但并未将它们连接起来搭建出一个神经网络，forward()函数的作用就是搭建一个神经网络，使得输入的数据沿着指定的结构进行前向传播：</p><ul><li>forward除了self之外，还接收一个参数x作为输入数据。</li><li>x &#x3D; self.conv1(x)：输入的x经过卷积计算后得到x1，对应于卷积层C1。</li><li>x2 &#x3D; F.relu(x1) ：对卷积后的数据进行ReLU激活操作。</li><li>x3 &#x3D; self.pool1(x2) ：对数据进行池化，对应于下采样层S2。</li><li>……</li><li>与上面类似，数据依次经过卷积层C3、下采样层S4、全连接层C5、全连接层F6以及输出层，从而使输入x沿着指定的路径得到最终的输出。</li></ul><p><strong>注：</strong></p><ul><li><p>为了更好的展示数据如何沿着神经网络进行前向传播，这里对每一层的输出设置了不同的变量命名，实际应用时，可以将x1~x12都写作x，只要不影响前向传播即可。</p></li><li><p>二维卷积以及池化操作得到的是二维的特则图，但全连接层需要一维的数据，因此需要对数据尺寸进行修改，即：</p><pre><code class="python">x7 = x.reshape(x6.shape[0], -1)</code></pre></li></ul></li></ul><h3 id="3-2-使用序列化方法"><a href="#3-2-使用序列化方法" class="headerlink" title="3.2 使用序列化方法"></a>3.2 使用序列化方法</h3><p>这种方式使用torch.nn.Sequential方式定义模型，将神经网络以序列的方式进行连接，每个层使用前面层计算的输出作为输入，并且在内部会维护层与层之间的权重矩阵和偏置向量。</p><pre><code class="python">from torch import nnin_channels = 1model = nn.Sequential(    nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1),    nn.ReLU(),    nn.MaxPool2d(kernel_size=2, stride=2),    nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1),    nn.ReLU(),    nn.MaxPool2d(kernel_size=2, stride=2),    nn.Flatten(),    nn.Linear(in_features=16 * 4 * 4, out_features=120),    nn.Linear(in_features=120, out_features=84),    nn.Linear(in_features=84, out_features=10))</code></pre><h3 id="3-3总结"><a href="#3-3总结" class="headerlink" title="3.3总结"></a>3.3总结</h3><ol><li>第一种可以更好的根据需要搭建网络结构；</li><li>第二种方式网络以序列的方式搭建网络，不适用于复杂网络；</li><li>对于一些复杂的含有重复层的网络，可将两种方式结合使用。序列化方法定义重复层，然后使用第一种方式根据网络结构进行组装。</li></ol><h2 id="4-定义损失函数以及优化器"><a href="#4-定义损失函数以及优化器" class="headerlink" title="4. 定义损失函数以及优化器"></a>4. 定义损失函数以及优化器</h2><ul><li><p>损失函数</p><p>损失函数用于计算真实值和预测值之间的差异。在<a href="https://pytorch.org/docs/stable/nn.html#loss-functions">PyTorch官方文档</a>中，给出了可用的损失函数列表。</p><p>这里，我们使用交叉熵损失函数<strong>torch.nn.CrossEntropyLoss()<strong>。</strong>该损失函数内部自动加上了Softmax</strong>，用于解决多分类问题，也可用于解决二分类问题。</p></li><li><p>优化器</p><p>优化器根据损失函数求出的损失，对神经网络的参数进行更新。在<a href="https://pytorch.org/docs/stable/optim.html">PyTorch官方文档</a>中，给出了可用的优化器。</p><p>这里，我们使用**torch.optim.Adam()**作为我们的优化器。</p></li></ul><pre><code class="python">from torch import nn, optimcriterion = nn.CrossEntropyLoss()  # 损失函数optimizer = optim.Adam(model.parameters())  # 优化器</code></pre><p>其中：</p><ul><li>model.parameters()是待优化的参数。</li></ul><h2 id="5-训练模型"><a href="#5-训练模型" class="headerlink" title="5.训练模型"></a>5.训练模型</h2><p>模型的训练主要包括3部分：</p><ul><li>前向传播</li><li>反向传播</li><li>梯度下降</li></ul><p>简单的说就是取出数据，放到模型里面跑一次得到预测值，计算与真实值之间的损失，然后计算梯度，根据梯度更新一次网络。</p><p>代码实现如下：</p><pre><code class="python">device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)model = my_CNN(1).to(device)  # 加载模型到设备num_epochs = 100for epoch in range(num_epochs):    for batch_idx, (data, label) in enumerate(train_loader):        data = data.to(device=device)  # 加载数据到设备        label = label.to(device=device)        # 前向传播        pre = model(data)        loss = criterion(pre, label)        # 反向传播        optimizer.zero_grad()        loss.backward()        # 梯度下降        optimizer.step()</code></pre><p>其中：</p><ul><li><p>torch.device(‘cuda’ if torch.cuda.is_available() else ‘cpu’)：选择使用GPU或者CPU训练，若电脑有GPU且配置正确，则使用GPU训练，否则使用CPU训练（模型和数据必须都放在GPU或者CPU上）。</p></li><li><p>for epoch in range(num_epochs)：模型训练次数。</p></li><li><p>for batch_idx, (data, label) in enumerate(train_loader)：mini-batch对数据进行小批量训练。</p></li><li><p>前向传播：</p><ul><li>pre &#x3D; model(data)：将数据放入模型中训练。</li><li>loss &#x3D; criterion(pre, label)：通过损失函数得到本次训练的损失。</li></ul></li><li><p>反向传播：</p><ul><li>optimizer.zero_grad()：将梯度归零。训练时通常使用mini-batch方法，<strong>如果不将梯度清零的话，梯度会与上一个batch的梯度相关，因此该函数要写在反向传播和梯度下降之前</strong>。</li><li>loss.backward()：反向传播。计算得到每个参数的梯度。</li></ul></li><li><p>梯度下降</p><p>optimizer.step()：执行一次优化步骤，对参数进行更新。注意：optimizer.step()只负责通过梯度下降对参数进行优化，并不负责产生梯度，梯度是loss.backward()方法产生的。</p></li></ul><h2 id="6-测试模型"><a href="#6-测试模型" class="headerlink" title="6. 测试模型"></a>6. 测试模型</h2><p>模型训练完毕后，可以使用测试集对模型进行测试：</p><pre><code class="python">loss = 0with torch.no_grad():  # 关闭梯度计算    model.eval()  # 评估模式    for batch_idx, (data, label) in enumerate(test_loader):        data = data.to(device=device)        label = label.to(device=device)        pre = model(data)        loss += criterion(pre, label).item()model.train()  # 训练模式loss = loss / len(test_loader.dataset)</code></pre><p>其中：</p><ul><li><p>with torch.no_grad()：关闭梯度计算。在训练模型时，需要计算根据反向传播计算梯度以更新参数，但在对验证集或者测试集进行预测时，并不需要更新参数，因此也就不需要计算梯度。因此，为了避免浪费计算资源，在模型评估时最后关闭梯度计算。</p></li><li><p>model.eval()：将模型切换到评估模式。在神经网络中，出于防止过拟合等目的，一般会加入Dropout和Batch Normalization层，在模型训练阶段，根据输入数据的变化，这些层的参数也会发生变化。<strong>在评估模式下，Dropout层会让所有的网络节点都生效，而Batch Normalization层会停止计算和更新均值和方差，直接使用在训练阶段已经学出的均值和方差。</strong></p></li><li><p>model.train()：将模型切换到训练模式。此时Dropout层使网络中的节点以一定概率失效，Batch Normalization层根据输入的数据更新均值和方差。<strong>在将模型切换到评估模式之后，在下一次训练之前必须再切换到训练模式。</strong></p></li><li><p>注意with torch.no_grad()和model.eval()的区别：</p><p>with torch.no_grad()关闭的是梯度计算，和神经网络整体有关；而model.eval()和梯度没有关系，只和Dropout和Batch Normalization这两层有关系。</p></li></ul><h2 id="7-整体代码"><a href="#7-整体代码" class="headerlink" title="7. 整体代码"></a>7. 整体代码</h2><p>以下是最终的代码（使用前馈神经网络的方式定义神经网络）。由于这里仅仅是为了介绍如何搭建一个模型，另外出于篇幅考虑，对于一些细节方面未做具体改进，主要包括以下几点：</p><ul><li>除了训练集和测试集之外，还可以使用验证集评估模型性能以设置早停</li><li>为了得到更好的模型性能，一般会对数据进行归一化</li></ul><pre><code class="python">import torchimport torch.nn as nnimport torch.nn.functional as Fimport torchvisionfrom torch import optimfrom torch.utils.data import DataLoaderfrom torchvision import transformsclass my_CNN(nn.Module):    def __init__(self, in_channels):        super(my_CNN, self).__init__()        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1)  # 定义卷积核        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # 定义最大池化层        self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(in_features=16 * 4 * 4, out_features=120)  # 定义全连接层        self.fc2 = nn.Linear(in_features=120, out_features=84)        self.fc3 = nn.Linear(in_features=84, out_features=10)    def forward(self, x):        x = self.conv1(x)  # 卷积层C1        x = F.relu(x)  # 激活函数        x = self.pool1(x)  # 下采样层S2        x = self.conv2(x)  # 卷积层C3        x = F.relu(x)        x = self.pool2(x)  # 下采样层S4        x = x.reshape(x.shape[0], -1)  # 二维变成一维，以输入到全连接层        x = self.fc1(x)  # 全连接层C5        x = F.relu(x)        x = self.fc2(x)  # 全连接层F6        x = F.relu(x)        x = self.fc3(x)  # 输出层        return xdef train(model, criterion, optimizer, train_loader, device, num_epochs=200):    for epoch in range(num_epochs):        for batch_idx, (data, label) in enumerate(train_loader):            data = data.to(device=device)  # 加载数据到设备            label = label.to(device=device)            # 前向传播            pre = model(data)            loss = criterion(pre, label)            # 反向传播            optimizer.zero_grad()            loss.backward()            # 梯度下降            optimizer.step()def test(model, criterion, test_loader, device):    loss = 0    with torch.no_grad():  # 关闭梯度计算        model.eval()  # 评估模式        for batch_idx, (data, label) in enumerate(test_loader):            data = data.to(device=device)            label = label.to(device=device)            pre = model(data)            loss += criterion(pre, label).item()    model.train()  # 训练模式    loss = loss / len(test_loader.dataset)    return lossdef main():    batch_size = 4    num_epochs = 200    train_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=True, transform=transforms.ToTensor(),                                               download=True)  # 下载数据集    test_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=False, transform=transforms.ToTensor(), download=True)    train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size,                              shuffle=True)  # 将数据集(Dataset)自动分成一个个的Batch,以用于批处理    test_loader = DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=True)    device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)  # 选择加载数据的设备，GPU或者CPU    model = my_CNN(1).to(device)  # 模型和数据应加载到同一种设备上    criterion = nn.CrossEntropyLoss()  # 损失函数    optimizer = optim.Adam(model.parameters())  # 优化器    train(model, criterion, optimizer, train_loader, device, num_epochs)    print(test(model, criterion, test_loader, device))if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt环境安装</title>
      <link href="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="下载Qt"><a href="#下载Qt" class="headerlink" title="下载Qt"></a>下载Qt</h2><h3 id="Qt资源下载地址"><a href="#Qt资源下载地址" class="headerlink" title="Qt资源下载地址"></a>Qt资源下载地址</h3><p> <a href="https://download.qt.io/archive">https://download.qt.io/archive</a></p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1.png" alt="1"></p><p>其中：</p><ul><li><p>qtcreator文件夹下存放的是不同版本的qtcreator，Qt Creator是一个用于Qt开发的轻量级跨平台集成开发环境</p></li><li><p>qt文件夹下存放的是不同版本的qt，Qt是一个跨平台的C++应用程序开发框架</p></li></ul><p>Qt从5.0版本开始自带Qt Creator，因此，若安装5.0以前版本的Qt需要再单独安装Qt Creator。我安装的是5.12.12，自带Qt Creator，因此不需要再单独安装。</p><h3 id="Qt5-12-12下载地址"><a href="#Qt5-12-12下载地址" class="headerlink" title="Qt5.12.12下载地址"></a>Qt5.12.12下载地址</h3><p><a href="https://download.qt.io/archive/qt/5.12/5.12.12](https://download.qt.io/archive/qt/5.12/5.12.12)">https://download.qt.io/archive/qt/5.12/5.12.12](https://download.qt.io/archive/qt/5.12/5.12.12)</a></p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/2.png" alt="2"></p><p>其中：</p><ul><li>.exe是Windows平台下的安装包</li><li>.dmg是Mac平台下的安装包</li><li>.run是Linux平台下的安装包</li></ul><p>点击对应平台下的安装包下载即可。若网页访问速度慢，可访问国内镜像网站：</p><ul><li><p><a href="https://mirrors.ustc.edu.cn/qtproject/archive">中国科学技术大学Qt镜像</a></p></li><li><p><a href="https://mirrors.sjtug.sjtu.edu.cn/qt/archive">上海交通大学Qt镜像</a></p></li></ul><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>以Windows平台下安装Qt 5.12.12为例，打开安装包：</p><ol><li><p>填写账号</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/3.png" alt="3"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/4.png" alt="4"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/5.png" alt="5"></p></li><li><p>选择安装路径（不要带中文）</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/6.png" alt="6"></p></li><li><p>选择组件，其中：</p><ul><li><p>MSVC：Microsoft Visual C++ Compiler，微软的VC编译器</p></li><li><p>MinGW：Minimalist GNU for Window，将GCC编译器和GNU Binutils移植到Windows平台下的产物，它是一些头文件和使用 GNU 工具集导入库的集合，允许用户在没有第三方 dll 的情况下生成本地的 Windows 程序</p><p><strong><font color="#0000dd">注：</font></strong></p><p><strong><font color="#0000dd">MSVC 和 MingGW 都是很好用的工具，但兼容并不好，比如某项目使用了 MingGW 编译，那么它所链接的库也必须是 MingGW 编译而成。 一般来说，如果仅在 Windows 平台开发，选择 MSVC，可以使用大量的第三方库；如果有跨平台需求，选择 MingGW。</font></strong></p><p><strong><font color="#0000dd">由于两个版本的Qt配置方式完全不同。因此在网上搜配置方法的时候，要加上MSVC或者MinGW这样的关键字搜索。</font></strong></p></li><li><p>UWP：属于 MSVC 编译器生成的 Qt 库，用于开发通用 Windows 平台的应用程序</p></li><li><p>Android：用于 Android 应用开发的 Qt 库</p></li><li><p>Sources：源码包，添加后可以使用源码调试功能</p></li><li><p>Qt Charts：二维图表模块，用于绘制柱状图、饼图、曲线图等常用二维图表</p></li><li><p>Qt Data Visualization：三维数据图表模块，用于数据的三维显示，如散点的三维空间分布、三维曲面等。</p></li></ul><ul><li>Qt Purchasing：用于处理 Android、iOS 和 macOS 上的应用内购买的跨平台 API</li><li>Qt Virtual Keyboard：Qt Quick 虚拟键盘</li><li>Qt WebEngine：集成了Google Chromium Web，充分利用了整个 Qt 图形堆栈集成，允许原生 Qt 控件与 Web 内容和 OpenGL 着色器的无缝混合和叠加</li><li>Qt Network Authorization：Qt 网络授权是一个附加库，它使 Qt 应用程序能够使用不同的 Web 身份验证系统</li><li>Qt WebGL Streaming Plugin：一个 Qt Platform Abstraction 插件，它通过网络将 Qt Quick &amp; Qt OpenGL 应用程序流式传输到支持 WebGL 的浏览器。</li><li><del>Qt Script (Deprecated)：脚本模块，已弃用</del></li></ul><p>Tools 节点下的工具：</p><ul><li><p>Qt Creator：Qt5.0版本以上集成的轻量级跨平台集成开发环境（5.0以下需要单独安装）</p></li><li><p>CDB Debugger Support：控制台调试器，是 MSVC 在 Qt 的原生调试器，由于MSVC 只有编译器，如果选择它，则需要勾选；如选择 MinGW 则不需要，MinGW 中有 GDB调试器</p></li><li><p>MingGW ：这里的 MingGW 是用来交叉编译的，在一个平台上生成另一个平台上的可执行代码</p></li><li><p>Strawberry Perl：Perl 语言工具</p><p>根据个人需要，我选择了以下组件（若不确定选哪个，可以全选）</p></li></ul><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/7.png" alt="7"></p></li><li><p>许可协议</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/8.png" alt="8"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/9.png" alt="9"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/10.png" alt="10"></p></li><li><p>等待安装完成</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/11.png" alt="11"></p></li><li><p>安装完成</p></li></ol><p>   <img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/12.png" alt="12"></p><h2 id="创建快捷方式"><a href="#创建快捷方式" class="headerlink" title="创建快捷方式"></a>创建快捷方式</h2><p>安装好后的Qt Creator未在桌面创建快捷方式，可以使用以下方式创建：</p><ol><li><p>打开“开始菜单”，找到安装好的“Qt Creator”，然后“右键”-&gt;“更多”-&gt;“打开文件位置”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/13.jpg" alt="13"></p></li><li><p>在“Qt Creator”上右键，然后”发送到”-&gt;“桌面快捷方式”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/14.jpg" alt="14"></p></li></ol><h2 id="“Hello-World”之第一个Qt应用"><a href="#“Hello-World”之第一个Qt应用" class="headerlink" title="“Hello World”之第一个Qt应用"></a>“Hello World”之第一个Qt应用</h2><ol><li><p>打开Qt Creator，“文件”-&gt;“新建文件或项目”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/15.png" alt="15"></p></li><li><p>选择模板，部分选项如下：</p><ul><li>Qt Widgets Application，支持桌面平台的GUI 界面应用程序</li><li>Qt Console Application，控制台应用程序，无 GUI 界面</li><li>Application（Qt Quick），创建可部署的 Qt Quick 2 应用程序。Qt Quick 是 Qt 支持的一套 GUI 开发架构，其界面设计采用 QML 语言，程序架构采用 C++ 语言。利用 Qt Quick 可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计</li></ul><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/16.png" alt="16"></p></li><li><p>工程路径，注意路径及工程名字不能含有空格或中文</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/17.png" alt="17"></p></li><li><p>选择构建系统，其中：</p><ul><li>qmake，为 Qt 量身打造的，使用起来非常方便</li><li>cmake，使用上不如qmake简单直接，但复杂换来的是强大的功能</li><li>Qbs ，号称下一代构建工具</li></ul><p>对简单的Qt工程，采用 qmake；对复杂度超过 qmake 处理能力的，采用 cmake。这里我选择qmake。</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/18.png" alt="18"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/19.png" alt="19"></p></li><li><p>翻译文件，用于国际化，暂时不用设置，默认即可</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/20.png" alt="20"></p></li><li><p>选择构建套件，这里我选择MinGW 64-bit，不同构建套件的区别见上面“安装Qt”中的“选择组件”步骤</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/21.png" alt="21"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/22.png" alt="22"></p></li><li><p>打开 .ui 文件</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/23.png" alt="23"></p></li><li><p>在“Display Widgets”下拖一个“Label”到中间，在其中填入“Hello World”，并在右侧修改宽度</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/24.png" alt="24"></p></li><li><p>点击左下角的“绿色三角形”运行程序</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/25.png" alt="25"></p></li><li><p>程序运行成果，显示GUI界面</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/26.png" alt="26"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离思五首·其四</title>
      <link href="/2023/07/08/%E7%A6%BB%E6%80%9D%E4%BA%94%E9%A6%96%C2%B7%E5%85%B6%E5%9B%9B/"/>
      <url>/2023/07/08/%E7%A6%BB%E6%80%9D%E4%BA%94%E9%A6%96%C2%B7%E5%85%B6%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<center>离思五首·其四</center><p align="right">元稹【唐】</p><hr><center>曾经沧海难为水，</center><center>除却巫山不是云。</center><center>取次花丛懒回顾，</center><center>半缘修道半缘君。</center><p>第一次读到这首诗的时候，因为没读懂“曾经”两个字，所以对前两句半知半解，只觉得后两句写得很妙。后来某一天突然醒悟过来，“曾经”是两个词：曾经经过，这才体会到前两句的韵味。特别是最近想起来这首诗，更是咂摸出一番新的滋味。<br>“领略过沧海的波涛汹涌，别处的水就不值得看了；沉醉过巫山云景的梦幻飘渺，别处的云都不能被叫作云景了；即使从万花丛中走过，也懒得看一眼”如果只读到前三句，可能会是一头雾水，这到底想表达什么意思？为什么别处的水不值得看？为什么别处的云不能被叫作云景？为什么不看一眼身边的花？正当疑问之时，最后一句点名原因“一半是因为我在修道，另一半是因为你呀！”<br>个人认为，这首诗除了前两句的比喻极其绝妙之外，整体结构上也是极具深意的，可以说是含蓄美的极致体现。前三句不明说对你的爱慕，只是说沧海、说巫山云雨、说万花丛，直到最后一句点睛之笔才知道这哪是在说什么沧海云雨，这句句都是在说心上人啊！哪怕到了最后点名原因了，还要再说一句“半缘修道”，可是真的有一半原因是修道吗？恐怕未必，或者说“修道”本身也是“缘君”。这种写法， 层层递进，先是三句描写自己心态的句子，然后自然而然的说出自己为何这样，虽然整体上感觉不到太大的感情波动，但却将思恋之情委婉而又淋漓尽致的表现了出来。<br>如果换成现在，或许就是这样吧：<br>今天的晚霞好美，像一条红绸带从天边垂下；晚饭也很香，炸鸡腿外焦里嫩，咬一口嘎吱响。<br>但是我不想去看晚霞也没心思吃饭。<br>为什么？<br>因为最近很忙很累，嗯，更重要的是，好久不见想你了……</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
            <tag> 唐 </tag>
            
            <tag> 元稹 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
