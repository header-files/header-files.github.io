<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java8新特性1——函数式接口&amp;lambda表达式</title>
      <link href="/2023/09/02/Java8%E6%96%B0%E7%89%B9%E6%80%A71%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&amp;lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/09/02/Java8%E6%96%B0%E7%89%B9%E6%80%A71%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&amp;lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/09/02/Java8%E6%96%B0%E7%89%B9%E6%80%A71%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3&lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">Java8新特性1——函数式接口&amp;lambda表达式</a></li><li>方法引用</li><li>Stream</li></ul><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><p>如果在一个接口中，<strong>有且只有一个抽象方法</strong>，则该接口被称为函数式接口。如：</p><pre><code class="java">interface Test &#123;    void test();&#125;</code></pre><p>注：</p><p>可以在接口前使用 <code>@FunctionalInterface</code> 注解，判断这个接口是否是⼀个函数式接口。如：</p><pre><code class="java">@FunctionalInterfaceinterface Test1 &#123;//有且仅有一个抽象方法，是函数式接口    void test();&#125;@FunctionalInterfaceinterface Test2 &#123;//有且仅有一个抽象方法，是函数式接口    void test();    default void f() &#123;    &#125;&#125;@FunctionalInterfaceinterface Test3 &#123;//没有抽象方法，不是函数式接口，编译器报错&#125;@FunctionalInterfaceinterface Test4 &#123;//有多个抽象方法，不是函数式接口，编译器报错    void test1();    void test2();&#125;</code></pre><h2 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2. lambda表达式"></a>2. lambda表达式</h2><h3 id="2-1-lambda表达式作用"><a href="#2-1-lambda表达式作用" class="headerlink" title="2.1 lambda表达式作用"></a>2.1 lambda表达式作用</h3><p><strong>lambda表达式是一个匿名函数，用于简化函数式接口的实现</strong>。</p><p>在Java中，接口不能实例化，但接口对象可以指向实现类对象。当没有实现类对象时，可以通过匿名类的方式，如：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        Test test = new Test() &#123;            @Override            public void f() &#123;                System.out.println(&quot;使用匿名函数的方式实现了函数式接口&quot;);            &#125;        &#125;;        test.f();    &#125;&#125;@FunctionalInterfaceinterface Test &#123;    void f();&#125;</code></pre><p>使用匿名类的方式代码不是很简洁，因此引入了lambda表达式，如：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        Test test = () -&gt; System.out.println(&quot;使用lambda表达式的方式实现了函数式接口&quot;);        test.f();    &#125;&#125;@FunctionalInterfaceinterface Test &#123;    void f();&#125;</code></pre><p>在使用lambda表达式之后，代码变得简洁了很多，因此可以说<strong>lambda表达式是和函数式接口相辅相成的</strong>。在上面的代码中，lambda表达式实际做了以下三个工作：</p><ol><li><p>自动实现接口</p><pre><code class="java">Test test = new Test();</code></pre></li><li><p>将 <code>-&gt; </code> 前的参数自动添加到抽象函数里面（上面代码中抽象函数没有参数）</p><pre><code class="java">void f();</code></pre></li><li><p>将 <code>-&gt;</code> 后的语句作为抽象函数的方法体</p><pre><code class="java">void f()&#123;    System.out.println(&quot;使用lambda表达式的方式实现了函数式接口&quot;);&#125;</code></pre></li></ol><h3 id="2-2-lambda表达式语法格式"><a href="#2-2-lambda表达式语法格式" class="headerlink" title="2.2 lambda表达式语法格式"></a>2.2 lambda表达式语法格式</h3><p>lambda表达式的格式如下：</p><pre><code class="java">(参数1, 参数2, ……) -&gt; &#123;    方法体;&#125;</code></pre><p>其中：</p><ul><li>参数要求和函数式接口中抽象方法的参数一致（包括数量和类型以及顺序）</li><li>如果函数式接口中抽象方法有返回值，则实现的时候也需要返回值</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        Test test = (int x, int y) -&gt; &#123;//参数、返回值与函数式接口中抽象方法一致            return x + y;        &#125;;        test.add(1, 2);    &#125;&#125;@FunctionalInterfaceinterface Test &#123;    int add(int x, int y);&#125;</code></pre><h3 id="2-3-lambda表达式的精简"><a href="#2-3-lambda表达式的精简" class="headerlink" title="2.3 lambda表达式的精简"></a>2.3 lambda表达式的精简</h3><ul><li><p>参数精简</p><ul><li>参数类型可以省略，若省略一个类型参数，则所有的类型参数都要省略</li><li>若只有一个参数，则小括号可以省略</li><li>若参数为0或者多于1个，则小括号不可以省略</li></ul></li><li><p>方法体精简</p><ul><li>若方法体中只有一行代码，则花括号可以省略</li><li>若方法体中只有一行代码且是return语句，则在省略大括号的时候还需要去掉return关键字</li><li>若方法体中有多行代码或者使用了return语句，则大括号不可以省略</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        //只有一个参数，省略了小括号        //只有一条return语句，省略了花括号即return关键字        Test test = x -&gt; Math.exp(x);        test.exp(1);    &#125;&#125;@FunctionalInterfaceinterface Test &#123;    double exp(double x);&#125;</code></pre><h3 id="2-4-变量作用域"><a href="#2-4-变量作用域" class="headerlink" title="2.4 变量作用域"></a>2.4 变量作用域</h3><ol><li>lambda表达式只可以访问外部变量，但不能修改外部变量</li><li>lambda表达式访问的外部变量一般都是声明为 final 的，但也可以不用声明为 final ，但该变量在声明后不能被修改</li><li>lambda表达式中不允许声明一个与局部变量同名的<strong>参数</strong>或局部变量</li></ol><pre><code class="java">public class Main &#123;    static final int a = 0;    public static void main(String[] args) &#123;        final int num1 = 10;        int num2 = 20;        //num2 = 40; //声明后不能被修改        Test test1 = x -&gt; &#123;            System.out.println(num1);//可以访问外部被声明为 final 的变量            System.out.println(num2);//可以访问外部的普通变量            //num1 = 20;//只能访问，不能修改            //num2 = 20;//只能访问，不能修改            //int num1 = 20;//不允许声明一个与局部变量同名的局部变量            return Math.exp(x);        &#125;;        //num2 = 40; //声明后不能被修改        test1.exp(1);        //不允许声明一个与局部变量同名的参数        //Test test2 = num1 -&gt; Math.exp(num1);    &#125;&#125;@FunctionalInterfaceinterface Test &#123;    double exp(double x);&#125;</code></pre></li></ul><h2 id="3-四大函数式接口"><a href="#3-四大函数式接口" class="headerlink" title="3. 四大函数式接口"></a>3. 四大函数式接口</h2><p>为了让开发者高效地使用函数式接口，Java 8 在 <code>java.util.function</code> 包下提供了许多函数式接口，以下四种是最为常见的：</p><table><thead><tr><th align="center">接口原型</th><th align="center">抽象方法</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Consumer&lt; T &gt;</td><td align="center">accept(T t)</td><td align="center">消费型接口</td></tr><tr><td align="center">Supplier&lt; T &gt;</td><td align="center">T get()</td><td align="center">供给型接口</td></tr><tr><td align="center">Function&lt;T, R&gt;</td><td align="center">R apply(T t)</td><td align="center">函数型接口</td></tr><tr><td align="center">Predicate&lt; T &gt;</td><td align="center">boolean test(T t)</td><td align="center">断言型接口</td></tr></tbody></table><h3 id="3-1-Consumer-lt-T-gt-：消费型接口"><a href="#3-1-Consumer-lt-T-gt-：消费型接口" class="headerlink" title="3.1 Consumer&lt; T &gt;：消费型接口"></a>3.1 Consumer&lt; T &gt;：消费型接口</h3><p>该接口只接收输入参数但不输出返回值，<strong>消费对象，只进不出</strong>。</p><ul><li><p>接口原型：</p><pre><code class="java">@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    void accept(T t);&#125;</code></pre></li><li><p>使用示例：</p><pre><code class="java">import java.util.function.Consumer;public class Main &#123;    public static void main(String[] args) &#123;        Consumer&lt;Integer&gt; acc = (t) -&gt; System.out.println(t);//实现 Consumer 接口                acc.accept(10);    &#125;&#125;</code></pre></li></ul><h3 id="3-2-Supplier-lt-T-gt-：供给型接口"><a href="#3-2-Supplier-lt-T-gt-：供给型接口" class="headerlink" title="3.2 Supplier&lt; T &gt;：供给型接口"></a>3.2 Supplier&lt; T &gt;：供给型接口</h3><p>该接口只输出返回值但不接收输入参数，<strong>生成对象，只出不进</strong>。</p><ul><li><p>接口原型：</p><pre><code class="java">public interface Supplier&lt;T&gt; &#123;    T get();&#125;</code></pre></li><li><p>使用示例：</p><pre><code class="java">import java.util.function.Supplier;public class Main &#123;    public static void main(String[] args) &#123;        Supplier&lt;Integer&gt; sup = () -&gt; 10;//实现 Supplier 接口                System.out.println(sup.get());    &#125;&#125;</code></pre></li></ul><h3 id="3-3-Function-lt-T-R-gt-：函数型接口"><a href="#3-3-Function-lt-T-R-gt-：函数型接口" class="headerlink" title="3.3 Function&lt;T, R&gt;：函数型接口"></a>3.3 Function&lt;T, R&gt;：函数型接口</h3><p>该接口既接收输入参数又输出返回值，<strong>用于指定特定功能，有进有出</strong>。</p><ul><li><p>接口原型：</p><pre><code class="java">@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123;    R apply(T t);&#125;</code></pre></li><li><p>使用示例：</p><pre><code class="java">import java.util.function.Function;public class Main &#123;    public static void main(String[] args) &#123;        Function&lt;Integer, String&gt; fun = (x) -&gt; &#123;//实现 Function 接口            String out = &quot;输入的整数是&quot; + x;            return out;        &#125;;        System.out.println(fun.apply(10));    &#125;&#125;</code></pre></li></ul><h3 id="3-4-Predicate-lt-T-gt-：断言型接口"><a href="#3-4-Predicate-lt-T-gt-：断言型接口" class="headerlink" title="3.4 Predicate&lt; T &gt;：断言型接口"></a>3.4 Predicate&lt; T &gt;：断言型接口</h3><p>该接口既接收输入参数又输出返回值，且返回值只能是布尔值，<strong>用于条件判断，有进有出</strong>。</p><ul><li><p>函数原型：</p><pre><code class="java">public interface Predicate&lt;T&gt; &#123;    boolean test(T t);&#125;</code></pre></li><li><p>使用示例：</p><pre><code class="java">import java.util.function.Predicate;public class Main &#123;    public static void main(String[] args) &#123;        Predicate&lt;Integer&gt; pre = (x) -&gt; x % 2 == 0;//实现 Predicate 接口        int a = 10;        if (pre.test(10)) &#123;            System.out.println(a + &quot;是偶数&quot;);        &#125; else &#123;            System.out.println(a + &quot;是奇数&quot;);        &#125;    &#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolo源码注释4——yolo.py</title>
      <link href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py/"/>
      <url>/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码基于yolov5 v6.0</p></blockquote><p>目录：</p><ul><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">yolo源码注释1——文件结构</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释2——数据集配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释3——模型配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py">yolo源码注释4——yolo-py</a></li></ul><p>yolo.py 用于搭建 yolov5 的网络模型，主要包含 3 部分：</p><ul><li>Detect：Detect 层</li><li>Model：搭建网络</li><li>parse_model：根据配置实例化模块</li></ul><p>Model（仅注释了 init 函数）：</p><pre><code class="python">class Model(nn.Module):    # YOLOv5 model    def __init__(self, cfg=&#39;yolov5s.yaml&#39;, ch=3, nc=None, anchors=None):  # model, input channels, number of classes        super().__init__()        if isinstance(cfg, dict):            self.yaml = cfg  # model dict        else:  # is *.yaml            import yaml            self.yaml_file = Path(cfg).name            with open(cfg, encoding=&#39;ascii&#39;, errors=&#39;ignore&#39;) as f:                self.yaml = yaml.safe_load(f)        # Define model        ch = self.yaml[&#39;ch&#39;] = self.yaml.get(&#39;ch&#39;, ch)  # input channels        if nc and nc != self.yaml[&#39;nc&#39;]:            LOGGER.info(f&quot;Overriding model.yaml nc=&#123;self.yaml[&#39;nc&#39;]&#125; with nc=&#123;nc&#125;&quot;)            self.yaml[&#39;nc&#39;] = nc  # override yaml value        if anchors:            LOGGER.info(f&#39;Overriding model.yaml anchors with anchors=&#123;anchors&#125;&#39;)            self.yaml[&#39;anchors&#39;] = round(anchors)  # override yaml value        # 根据配置搭建网络        self.model, self.save = parse_model(deepcopy(self.yaml), ch=[ch])        self.names = [str(i) for i in range(self.yaml[&#39;nc&#39;])]  # default names        self.inplace = self.yaml.get(&#39;inplace&#39;, True)        # 计算生成 anchors 时的步长        m = self.model[-1]  # Detect()        if isinstance(m, Detect):            s = 256  # 2x min stride            m.inplace = self.inplace            m.stride = torch.tensor([s / x.shape[-2] for x in self.forward(torch.zeros(1, ch, s, s))])  # forward            check_anchor_order(m)  # must be in pixel-space (not grid-space)            m.anchors /= m.stride.view(-1, 1, 1)            self.stride = m.stride            self._initialize_biases()  # only run once        # Init weights, biases        initialize_weights(self)        self.info()        LOGGER.info(&#39;&#39;)</code></pre><p>parse_model：</p><pre><code class="python">def parse_model(d, ch):  # model_dict, input_channels(3)    LOGGER.info(f&quot;\n&#123;&#39;&#39;:&gt;3&#125;&#123;&#39;from&#39;:&gt;18&#125;&#123;&#39;n&#39;:&gt;3&#125;&#123;&#39;params&#39;:&gt;10&#125;  &#123;&#39;module&#39;:&lt;40&#125;&#123;&#39;arguments&#39;:&lt;30&#125;&quot;)    anchors, nc, gd, gw = d[&#39;anchors&#39;], d[&#39;nc&#39;], d[&#39;depth_multiple&#39;], d[&#39;width_multiple&#39;]    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)    # layers： 保存每一层的结构    # save： 记录 from 不是 -1 的层，即需要多个输入的层如 Concat 和 Detect 层    # c2: 当前层输出的特征图数量    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out    for i, (f, n, m, args) in enumerate(            d[&#39;backbone&#39;] + d[&#39;head&#39;]):  # from:-1, number:1, module:&#39;Conv&#39;, args:[64, 6, 2, 2]        m = eval(m) if isinstance(m, str) else m  # eval strings, m:&lt;class &#39;models.common.Conv&#39;&gt;        # 数字、列表直接放入args[i]，字符串通过 eval 函数变成模块        for j, a in enumerate(args):            try:                args[j] = eval(a) if isinstance(a, str) else a  # eval strings, [64, 6, 2, 2]            except NameError:                pass        # 对数量大于1的模块和 depth_multiple 相乘然后四舍五入        n = n_ = max(round(n * gd), 1) if n &gt; 1 else n  # depth gain        # 实例化 ymal 文件中的每个模块        if m in (Conv, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, MixConv2d, Focus, CrossConv,                 BottleneckCSP, C3, C3TR, C3SPP, C3Ghost,SE, FSM):            c1, c2 = ch[f], args[0]  # 输入特征图数量（f指向的层的输出特征图数量），输出特征图数量            # 如果输出层的特征图数量不等于 no (Detect输出层)            # 则将输出图的特征图数量乘 width_multiple ，并调整为 8 的倍数            if c2 != no:  # if not output                c2 = make_divisible(c2 * gw, 8)            args = [c1, c2, *args[1:]]  # 默认参数格式：[输入， 输出， 其他参数……]            # 参数有特殊格式要求的模块            if m in [BottleneckCSP, C3, C3TR, C3Ghost, CSPStage]:                args.insert(2, n)  # number of repeats                n = 1        elif m is nn.BatchNorm2d:            args = [ch[f]]        elif m is Concat:            c2 = sum(ch[x] for x in f)        elif m is Detect:            args.append([ch[x] for x in f])            if isinstance(args[1], int):  # number of anchors                args[1] = [list(range(args[1] * 2))] * len(f)        elif m is Contract:            c2 = ch[f] * args[0] ** 2        elif m is Expand:            c2 = ch[f] // args[0] ** 2        else:            c2 = ch[f]        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n &gt; 1 else m(*args)  # module        t = str(m)[8:-2].replace(&#39;__main__.&#39;, &#39;&#39;)  # module type        np = sum(x.numel() for x in m_.parameters())  # number params        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, &#39;from&#39; index, type, number params        LOGGER.info(f&#39;&#123;i:&gt;3&#125;&#123;str(f):&gt;18&#125;&#123;n_:&gt;3&#125;&#123;np:10.0f&#125;  &#123;t:&lt;40&#125;&#123;str(args):&lt;30&#125;&#39;)  # print        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist        layers.append(m_)        if i == 0:            ch = []        ch.append(c2)    return nn.Sequential(*layers), sorted(save)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolo源码注释3——模型配置文件</title>
      <link href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码基于yolov5 v6.0</p></blockquote><p>目录：</p><ul><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">yolo源码注释1——文件结构</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释2——数据集配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释3——模型配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py">yolo源码注释4——yolo-py</a></li></ul><p>模型配置文件一般放在 <code>models</code> 文件夹下的 <code>XXX.yaml</code> 文件中，以 <code>yolov5s.yaml</code> 为例：</p><pre><code class="yaml"># YOLOv5 🚀 by Ultralytics, GPL-3.0 license# Parametersnc: 80  # 类别个数，一定要与使用的数据集保持一致depth_multiple: 0.33  # 深度倍数，对数量大于1个模块进行数量控制，具体看 yolo.py 中的 parse_model 函数width_multiple: 0.50  # 宽度倍数，卷积操作中控制卷积核数量，具体看 yolo.py 中的 parse_model 函数# 检测框的大小anchors:  - [ 10,13, 16,30, 33,23 ]  # P3/8 检测小目标的三个检测框尺寸  - [ 30,61, 62,45, 59,119 ]  # P4/16 检测中等目标的三个检测框尺寸  - [ 116,90, 156,198, 373,326 ]  # P5/32 检测大目标的三个检测框尺寸# 1. P3 代表浅层的特征图，浅层的特征图较大包含更多的小目标# 2. P5 代表深层的特则图，深层的特征图较小包含更多的大目标# 3. YOLOv5 根据工程经验得到了这3组anchors，可以用于大多数数据集# 4. 在源代码中是针对 coco 数据集使用 K++ 算法求解出的大、中、小三种大小检测框# 5. 如果需要修改检测框大小，建议也是用 K++ 算法进行求解# YOLOv5 v6.0 backbone# 主干网络使用的模块，用于特征提取，可以替换为其他特征提取网络# 由于没有分neck模块，故spp写在了backbone部分backbone:  # 模块格式如下：[from, number, module, args]  # form： 当前的输入来自哪一层的输出， -1 表示上一层  # number： 当前模块的理论重复次数，当该值大于 1 时，与 depth_multiple 共同决定实际重复次数  # module： 模块名字，通过这个类名去 common.py 中寻找相应的类，进行模块化的搭建网络  # args： 搭建模块需要的参数，具体看 common.py 中对应的类的要求  [ [ -1, 1, Conv, [ 64, 6, 2, 2 ] ],  # 0-P1/2，模块编号为0    [ -1, 1, Conv, [ 128, 3, 2 ] ],  # 1-P2/4    [ -1, 3, C3, [ 128 ] ],    [ -1, 1, Conv, [ 256, 3, 2 ] ],  # 3-P3/8    [ -1, 6, C3, [ 256 ] ],    [ -1, 1, Conv, [ 512, 3, 2 ] ],  # 5-P4/16    [ -1, 9, C3, [ 512 ] ],    [ -1, 1, Conv, [ 1024, 3, 2 ] ],  # 7-P5/32    [ -1, 3, C3, [ 1024 ] ],    [ -1, 1, SPPF, [ 1024, 5 ] ],  # 9，模块编号为0  ]# YOLOv5 v6.0 head# 参数解释同backbone# 没有区分neck模块，所以head部分包含了PANet+Detect部分head:  [ [ -1, 1, Conv, [ 512, 1, 1 ] ],    [ -1, 1, nn.Upsample, [ None, 2, &#39;nearest&#39; ] ],    [ [ -1, 6 ], 1, Concat, [ 1 ] ],  # cat backbone 接受两层的输出作为输入：[ -1, 6 ] 表示上一层以及编号为 6 的层    [ -1, 3, C3, [ 512, False ] ],  # 13，模块编号为13    [ -1, 1, Conv, [ 256, 1, 1 ] ],    [ -1, 1, nn.Upsample, [ None, 2, &#39;nearest&#39; ] ],    [ [ -1, 4 ], 1, Concat, [ 1 ] ],  # cat backbone P3    [ -1, 3, C3, [ 256, False ] ],  # 17 (P3/8-small)    [ -1, 1, Conv, [ 256, 3, 2 ] ],    [ [ -1, 15 ], 1, Concat, [ 1 ] ],  # cat head P4    [ -1, 3, C3, [ 512, False ] ],  # 20 (P4/16-medium)    [ -1, 1, Conv, [ 512, 3, 2 ] ],    [ [ -1, 11 ], 1, Concat, [ 1 ] ],  # cat head P5    [ -1, 3, C3, [ 1024, False ] ],  # 23 (P5/32-large)    [ [ 18, 21, 24 ], 1, Detect, [ nc, anchors ] ],  # Detect(P3, P4, P5)  ]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolo源码注释2——数据集配置文件</title>
      <link href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码基于yolov5 v6.0</p></blockquote><p>目录：</p><ul><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">yolo源码注释1——文件结构</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释2——数据集配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释3——模型配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py">yolo源码注释4——yolo-py</a></li></ul><p>数据集配置文件一般放在 <code>data</code> 文件夹下的 <code>XXX.yaml</code> 文件中，格式如下：</p><pre><code class="yaml">path: # 数据集存放路径train: # 训练集图片存放路径val: # 验证集图片存放路径test: # 测试集存放路径（可不设置，如 coco128.yaml 就未设置）nc: # 目标检测中的类别数量names: # 列表，依次存放了类别的名字（数量要和 nc 匹配）download: # 下载数据集的脚本（如 Argoverse.yaml 中）或者数据集的下载链接（如 coco.yaml 中），也可不设置</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolo源码注释1——文件结构</title>
      <link href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码基于yolov5 v6.0</p></blockquote><p>目录：</p><ul><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A1%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">yolo源码注释1——文件结构</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释2——数据集配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A3%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">yolo源码注释3——模型配置文件</a></li><li><a href="/2023/08/14/yolo%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A4%E2%80%94%E2%80%94yolo-py">yolo源码注释4——yolo-py</a></li></ul><blockquote><ul><li>datasets # 用于存放数据集的默认文件夹</li><li>yolov5<ul><li>data # 模型训练的超参数配置文件以及数据集配置文件<ul><li>hyps # 存放超参数配置文件（yaml格式）<ul><li>hyp.scratch-high.yaml：适用于较大的模型结构，如 yolol</li><li>hyp.scratch-low.yaml：适用于较小的模型结构，如 yolos</li><li>hyp.scratch-med.yaml：适用于中等模型结构，如 yolom</li></ul></li><li>images # 存放了官方提供的两张测试图片：bus.jpg 和 zidane.jpg</li><li>scripts # 用于下载数据集以及权重文件的shell脚本<ul><li>download_weight.sh：下载权重文件</li><li>get_coco.sh：下载 coco 数据集</li><li>get_coco128.sh：下载 coco128 数据集</li></ul></li><li>XXX.yaml：各种数据集的配置文件，如 coco.yaml 是 coco 数据集的配置文件</li></ul></li><li>models # 搭建模型的相关配置文件及代码<ul><li>hub # 存放各版本网络模型的配置文件<ul><li>anchors.yaml：coco 数据集的默认 anchor</li><li>yolovX-XXX.yaml：模型配置文件</li></ul></li><li>common.py：用于搭建网络的模块，如Conv、DWConv、TransformerLayer等</li><li>experimental.py：实验性质的代码，其中一些模块是近几年提出来的，如CrossConv、Sum等，yolov5的作者尝试将其融合进yolov5中</li><li>tf.py：TensorFlow版本的yolov5代码</li><li>yolo.py：主要用于搭建yolov5的网络模型</li><li>yolov5X.yaml：yolov5的模型配置文件</li></ul></li><li>runs #运行过程中产生的文件夹，每运行一次都会生成一个名为 expN 的文件夹（N代表运行次数）<ul><li>detect # 运行 detect.py 产生的图片，图片中标注出识别到的物体及其概率</li><li>train # 运行 train.py 产生的文件<ul><li>weights # 权重（包括训练出的最好权重 best.pt 以及上次训练的权重 last.pt）</li><li>confusion_matrix.png：混淆矩阵</li><li>F1_curve.png：F1 score 与置信度之间的关系</li><li>hyp.yaml：超参数记录文件</li><li>labels.jpg：包含四张子图，从左上到右下分别是每个类别的个数、标注的 bbox、标注的bbox的中心点坐标热图、bbox的宽高热图</li><li>labels_correlogram.jpg：预测框的宽高以及中心坐标热图</li><li>opt.yaml：模型记录文件</li><li>P_curve.png：准确率与置信度之间的关系</li><li>PR_curve.png：精准率与召回率之间的关系</li><li>R_curve.png：精准率与置信度之间的关系</li><li>results.csv：模型训练过程中的指标，如损失函数、准确率等</li><li>results.png：训练集以及验证集在验证过程中的损失函数、mAP等指标的曲线</li><li>train_bathN.jpg：训练集图像（带bbox）</li><li>val_batchN_labels.jpg：验证集图像（带bbox）</li><li>val_batchN_pred.jpg：验证集图像（带预测框）</li></ul></li></ul></li><li>utils # 通用的工具类函数<ul><li>aws：恢复中断训练相关</li><li>docker：docker配置相关</li><li>flash_rest_api：flask接口相关</li><li>google_app_engine：google app相关</li><li>loggers：日志打印（包括TensorBoard）</li><li>activations.py：激活函数</li><li>augmentations.py：图像增强</li><li>autoanchor.py：自动生成 anchor</li><li>autobatch.py：自动生成 batch size</li><li>benchmarks.py：评估模型的推理速度以及分析内存占用</li><li>callbacks.py：主要是 logger 的回调函数</li><li>datasets.py：配置 dataloader 和 datasets</li><li>downloads.py：下载数据集</li><li>general.py：通用函数</li><li>loss.py：损失函数</li><li>metrics.py：模型验证指标</li><li>plots.py：绘制损失函数等的曲线、bbox等</li><li>torch_utils.py：其他一些通用函数</li></ul></li><li>detect.py：将训练好的模型用于图片、视频等进行目标检测</li><li>export.py：导出模型</li><li>hubconf.py：pytorch hub 相关，用于定义和管理模型的预训练权重和配置信息</li><li>train.py：训练模型</li><li>val.py：验证模型，评估模型性能</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测常用的数据集格式</title>
      <link href="/2023/08/09/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/08/09/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在目标检测领域，有三种常用的数据集：</p><table><thead><tr><th align="center">数据集</th><th align="center">标注文件格式</th><th align="left">bbox格式</th></tr></thead><tbody><tr><td align="center"><a href="http://host.robots.ox.ac.uk/pascal/VOC/">voc</a></td><td align="center">xml</td><td align="left">xmin, ymin, xmax, ymax:<br />bbox左上角(xmin, ymin)和右下角(xmax, ymax)的坐标</td></tr><tr><td align="center"><a href="https://cocodataset.org/#home">coco</a></td><td align="center">json</td><td align="left">x, y, w, h:<br />bbox左上角坐标(x, y)以及宽(w)和高(h)</td></tr><tr><td align="center">yolo</td><td align="center">txt</td><td align="left">xcenter, ycenter, w, h:<br />bbox的中心x坐标(xcenter)、y坐标(ycenter)以及宽度(w)和高度(h)<br />xcenter, w相对图片实际宽度W做了归一化，即：xcenter&#x2F;W, w&#x2F;W <br />ycenter, h相对图片图片高度H做了归一化，即：ycenter&#x2F;H, h&#x2F;H</td></tr></tbody></table><h2 id="1-voc格式"><a href="#1-voc格式" class="headerlink" title="1. voc格式"></a>1. voc格式</h2><h3 id="1-1-文件结构"><a href="#1-1-文件结构" class="headerlink" title="1.1 文件结构"></a>1.1 文件结构</h3><p>该文件结构指的是从 <a href="http://host.robots.ox.ac.uk/pascal/VOC/">voc 官网</a>下载的数据的文件结构（不同年份的数据集略有不同，但结构大致相同）。</p><blockquote><p>VOCdevkit # 根目录</p><ul><li>VOCXXXX # 不同年份的数据集，目前有 2005 年到 2012 年的<ul><li>Annotations # 存放 xml 格式的标注文件，与 JPEGImages 下的图片一一对应，每个 xml 文件都描述一张图片的信息</li><li>ImageSets # 存放的是 txt 文件，文件中每一行包含一张图片的名称以及 ±1 表示正负样本<ul><li>Layout # 可用于检测人体部位的数据（train.txt 用于训练的图片、trainval.txt用于训练和验证的图片合集、val.txt 用于验证的图片，下同）</li><li>Main # <strong>可用于目标检测的数据</strong></li><li>Segmentation # 可用于图像分割的数据</li></ul></li><li>JPEGImages # 存放图片</li><li>SegmentationClass # 存放按照类别分割的图片，可用于语义分割</li><li>SegmentationObject # 存放按照个体分割的图片，可用于实例分割</li></ul></li></ul></blockquote><h3 id="1-2-标注文件"><a href="#1-2-标注文件" class="headerlink" title="1.2 标注文件"></a>1.2 标注文件</h3><p>voc格式的数据集使用 xml 文件标注图片及其bbox信息，一张图片对应个xml文件，以 Main 中其中一个xml文件的部分内容为例：</p><pre><code class="xml">&lt;annotation&gt;    &lt;folder&gt;VOC2007&lt;/folder&gt;  &lt;!--图片所在文件夹（实际用不到）--&gt;    &lt;filename&gt;000005.jpg&lt;/filename&gt; &lt;!--图片文件名--&gt;    &lt;source&gt; &lt;!--图片来源--&gt;        &lt;database&gt;The VOC2007 Database&lt;/database&gt;        &lt;annotation&gt;PASCAL VOC2007&lt;/annotation&gt;        &lt;image&gt;flickr&lt;/image&gt;        &lt;flickrid&gt;325991873&lt;/flickrid&gt;    &lt;/source&gt;    &lt;owner&gt; &lt;!--图片拥有者--&gt;        &lt;flickrid&gt;archintent louisville&lt;/flickrid&gt;        &lt;name&gt;?&lt;/name&gt;    &lt;/owner&gt;    &lt;size&gt; &lt;!--图片宽度、高度、通道数量--&gt;        &lt;width&gt;500&lt;/width&gt;        &lt;height&gt;375&lt;/height&gt;        &lt;depth&gt;3&lt;/depth&gt;    &lt;/size&gt;    &lt;segmented&gt;0&lt;/segmented&gt; &lt;!--是否用于分割--&gt;    &lt;object&gt; &lt;!--标注目标1--&gt;        &lt;name&gt;chair&lt;/name&gt; &lt;!--物体类别--&gt;        &lt;pose&gt;Rear&lt;/pose&gt; &lt;!--拍摄角度： front, rear, left, right, unspecified--&gt;        &lt;truncated&gt;0&lt;/truncated&gt; &lt;!--目标是否被截断--&gt;        &lt;difficult&gt;0&lt;/difficult&gt; &lt;!--检测难易程度--&gt;        &lt;bndbox&gt; &lt;!--标注目标1的 bbox--&gt;            &lt;xmin&gt;263&lt;/xmin&gt;            &lt;ymin&gt;211&lt;/ymin&gt;            &lt;xmax&gt;324&lt;/xmax&gt;            &lt;ymax&gt;339&lt;/ymax&gt;        &lt;/bndbox&gt;    &lt;/object&gt;    &lt;object&gt; &lt;!--标注目标2的 bbox--&gt;        &lt;name&gt;chair&lt;/name&gt;        &lt;pose&gt;Unspecified&lt;/pose&gt;        &lt;truncated&gt;0&lt;/truncated&gt;        &lt;difficult&gt;0&lt;/difficult&gt;        &lt;bndbox&gt;            &lt;xmin&gt;165&lt;/xmin&gt;            &lt;ymin&gt;264&lt;/ymin&gt;            &lt;xmax&gt;253&lt;/xmax&gt;            &lt;ymax&gt;372&lt;/ymax&gt;        &lt;/bndbox&gt;    &lt;/object&gt;    &lt;!--其余标注信息结构同上--&gt;&lt;/annotation&gt;</code></pre><h2 id="2-coco格式"><a href="#2-coco格式" class="headerlink" title="2. coco格式"></a>2. coco格式</h2><h3 id="2-1-文件结构"><a href="#2-1-文件结构" class="headerlink" title="2.1 文件结构"></a>2.1 文件结构</h3><p>该文件结构指的是从 <a href="https://cocodataset.org/#home">coco 官网</a>下载的数据的文件结构。</p><blockquote><ul><li>annotations_XXXX # 存放 json 格式的标注文件，一个 json 文件里面包含了多张图片的相关信息<ul><li>annotations<ul><li>caption_xxxx.json # 存储图像标注用于描述图像</li><li>instances_xxxx.json # <strong>用于目标检测的标注信息</strong></li><li>person_keypoints_xxxx.json # 目标上的关键点信息</li></ul></li></ul></li><li>trainXXX # 存放训练集图片</li><li>valXXXX # 存放验证集图片</li></ul></blockquote><h3 id="2-2-标注文件"><a href="#2-2-标注文件" class="headerlink" title="2.2 标注文件"></a>2.2 标注文件</h3><p>coco格式的数据集使用 json 文件标注图片及其 bbox 信息，与voc格式一张图片对应一个xml文件不同，coco格式中一个 json 文件里面存放了若干张图片的信息。以 instances_xxxx.json 中的部分内容为例：</p><pre><code class="json">&#123;    &quot;info&quot;: &#123; #数据集描述信息        &quot;description&quot;: &quot;COCO 2017 Dataset&quot;, # 数据集描述        &quot;url&quot;: &quot;http://cocodataset.org&quot;, # 数据集地址        &quot;version&quot;: &quot;1.0&quot;, # 数据集版本        &quot;year&quot;: 2017, # 数据集年份        &quot;contributor&quot;: &quot;COCO Consortium&quot;, # 数据集提供者        &quot;date_created&quot;: &quot;2017/09/01&quot; # 数据集创建日期    &#125;,    &quot;licenses&quot;: [ # 许可协议        &#123;            &quot;url&quot;: &quot;http://creativecommons.org/licenses/by-nc-sa/2.0/&quot;, # 协议链接            &quot;id&quot;: 1, # 协议 id ，下面将会用到            &quot;name&quot;: &quot;Attribution-NonCommercial-ShareAlike License&quot; # 协议名称        &#125;        # 其他许可协议格式同上    ],    &quot;images&quot;: [ # 图片信息        &#123;            &quot;license&quot;: 4, # 使用的许可协议            &quot;file_name&quot;: &quot;000000397133.jpg&quot;, # 图片文件名            &quot;coco_url&quot;: &quot;http://images.cocodataset.org/val2017/000000397133.jpg&quot;, # 图片在 coco 上的url            &quot;height&quot;: 427, # 图片高度            &quot;width&quot;: 640, # 图片宽度            &quot;date_captured&quot;: &quot;2013-11-14 17:02:52&quot;, # 图片获取日期            &quot;flickr_url&quot;: &quot;http://farm7.staticflickr.com/6116/6255196340_da26cf2c9e_z.jpg&quot;, 图片在 flickr 上的url            &quot;id&quot;: 397133 # 图片 id        &#125;        # 其他图片信息格式同上    ],    &quot;annotations&quot;: [ # 标注信息        &#123;            &quot;segmentation&quot;: [ # 实例分割时的边界点坐标[x1, y1, x2, y2 …… xn, yn]                [                    510.66,                    423.01,                    ……,                    510.45,                    423.01                ]            ],            &quot;area&quot;: 702.1057499999998, # 区域面积            &quot;iscrowd&quot;: 0, # 目标是否被遮盖            &quot;image_id&quot;: 289343, # 标注所在的图片的 id 编号（与上面 images 中的对应）            &quot;bbox&quot;: [ # bbox框 [左上角x, 左上角y, 宽度, 高度]                473.07,                395.93,                38.65,                28.67            ],            &quot;category_id&quot;: 18, # 被标注物体对应的类别 id 编号（与下面 categories 中的对应）            &quot;id&quot;: 1768 # 该标注的 id 编号（唯一）        &#125;        # 其他标注信息格式同上    ],    &quot;categories&quot;: [ # 类别描述        &#123;            &quot;supercategory&quot;: &quot;person&quot;, # 该类别所属的大类            &quot;id&quot;: 1, # 类别 id 编号            &quot;name&quot;: &quot;person&quot; # 类别名字        &#125;        # 其他标注信息格式同上    ]&#125;</code></pre><h2 id="3-yolo格式"><a href="#3-yolo格式" class="headerlink" title="3. yolo格式"></a>3. yolo格式</h2><h3 id="3-1-文件结构"><a href="#3-1-文件结构" class="headerlink" title="3.1 文件结构"></a>3.1 文件结构</h3><p>使用yolo时，默认的文件结构如下（不同数据集会略有不同，但结构大致相同）：</p><blockquote><p>XXXX # 根目录，视使用的数据集决定</p><ul><li>images # 存放图片，已划分为训练集、验证集、测试集（部分数据集无测试集）<ul><li>train</li><li>val</li><li>test</li></ul></li><li>labels # 存放的是 txt 文件，每个txt文件对应一张图片，文件中每一行包含一个bbox的相关信息<ul><li>train</li><li>val</li><li>test</li></ul></li></ul></blockquote><h3 id="3-2-标注文件"><a href="#3-2-标注文件" class="headerlink" title="3.2 标注文件"></a>3.2 标注文件</h3><p>yolo格式的数据集使用 txt 文件标注图片bbox信息，一张图片对应一个txt文件，txt文件中的每一行都标注了一个bbox的相关信息。标注格式如下：</p><blockquote><p>&lt;类别索引&gt; &lt;bbox的中心x坐标&gt; &lt;bbox的中心y坐标&gt; &lt;bbox的宽度&gt; &lt;bbox的高度&gt;</p></blockquote><ul><li>信息之间以空格分割</li><li>bbox的中心xy坐标以及宽度、高度都相对于图片的实际宽度W和高度H做了归一化</li></ul><p>以其中一个txt文件的部分内容为例：</p><pre><code>45 0.479492 0.688771 0.955609 0.5955# 标注目标1的 bbox的类别索引是45，中心x坐标是0.479492， 中心y坐标是0.688771， 宽度是0.955609， 高度是0.595545 0.736516 0.247188 0.498875 0.476417# 标注目标2的 bbox# 其余标注信息结构同上</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> CV基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> CV基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉应用方向</title>
      <link href="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/"/>
      <url>/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>计算机视觉可以大致有以下几个方向（更详细的可以参考<a href="https://paperswithcode.com/sota">papers with code</a>）：</p><ul><li>图像分类</li><li>目标检测</li><li>图像分割</li><li>图像生成</li><li>风格迁移</li><li>超分辨率</li></ul><h2 id="1-图像分类"><a href="#1-图像分类" class="headerlink" title="1. 图像分类"></a>1. 图像分类</h2><p>图像分类是是视觉识别中的一项基本任务，目的是<strong>分辨整个图像并将其分类</strong>。</p><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB.jpg" alt="图像分类"></p><h3 id="1-1-常用数据集"><a href="#1-1-常用数据集" class="headerlink" title="1.1 常用数据集"></a>1.1 常用数据集</h3><ul><li><a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>：手写数字数据集，包含 60000 张训练集和 10000 张测试集</li><li><a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a>：包含飞机、汽车、鸟、猫等10个类别，每个类别包含 5000 张训练图像和 1000 张测试图像</li><li><a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-100</a>：包含 100 个类，每个类别有 500 张训练图像和 100 张测试图像</li></ul><h2 id="2-目标检测"><a href="#2-目标检测" class="headerlink" title="2. 目标检测"></a>2. 目标检测</h2><p>目标检测的目的是<strong>找到并识别图像中的物体</strong>。如下图所示，一张图中包含多个物体，目标检测的任务是识别图像中不同物体的位置和边界，并将对象分类为各自的类别。</p><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B.jpg" alt="目标检测"></p><h3 id="2-1-常用数据集"><a href="#2-1-常用数据集" class="headerlink" title="2.1 常用数据集"></a>2.1 常用数据集</h3><ul><li><a href="https://cocodataset.org/#home">COCO</a></li><li><a href="http://host.robots.ox.ac.uk/pascal/VOC/">VOC</a></li></ul><h3 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h3><ul><li>one-state（优先考虑速度）：YOLO、SSD、Retina Net……</li><li>two-state（优先考虑精度）：R-CNN、Fast R-CNN、Faster R-CNN、Mask R-CNN……</li></ul><h2 id="3-图像分割"><a href="#3-图像分割" class="headerlink" title="3.图像分割"></a>3.图像分割</h2><p>基于目标检测，不仅需要检测出图像中存在的物体，还需要<strong>将图像中检测到的物体分割出来</strong>。<br>主要有以下三种：</p><ul><li>语义分割：在像素级别上的分类，将<strong>属于同一类的像素归为一类</strong></li><li>实例分割：分割出每个实例物体，<strong>将属于同一个体的像素归为一类</strong>，比如对图片中的多只狗都分割出来，并识别出来它们是不同的个体，而不仅仅是简单的对其进行分类为狗</li><li>全景分割：可以表示为语义分割和实例分割的组合，其中图像中<strong>每个实例都被分割并预测其身份</strong></li></ul><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2.jpg" alt="语义分割和实例分割"></p><h3 id="3-1-常用数据集"><a href="#3-1-常用数据集" class="headerlink" title="3.1 常用数据集"></a>3.1 常用数据集</h3><ul><li><a href="https://cocodataset.org/#home">COCO</a></li><li><a href="http://host.robots.ox.ac.uk/pascal/VOC/">VOC</a></li></ul><h3 id="3-2-常用方法"><a href="#3-2-常用方法" class="headerlink" title="3.2 常用方法"></a>3.2 常用方法</h3><ul><li>语义分割：FCN、U-Net、Mask R-CNN……</li><li>实例分割：R-CNN、Faster R-CNN、Mask R-CNN</li></ul><blockquote><p>注：</p><ul><li><p>图像分类重在分类，解决“是什么”的问题；</p></li><li><p>检测解决“在哪里，是什么”的问题；</p></li><li><p>分割解决“每一个像素属于哪个类别或物体”的问题。</p></li></ul></blockquote><h2 id="4-图像生成"><a href="#4-图像生成" class="headerlink" title="4. 图像生成"></a>4. 图像生成</h2><p>根据已有图片生成新的图片。</p><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90.jpg" alt="图像生成"></p><h2 id="5-风格迁移"><a href="#5-风格迁移" class="headerlink" title="5. 风格迁移"></a>5. 风格迁移</h2><p>将图像A的图像风格作用到图像B上，生成新的图片即符合A的风格又保留了B的内容。</p><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB.png" alt="风格迁移"></p><h2 id="6-超分辨率"><a href="#6-超分辨率" class="headerlink" title="6. 超分辨率"></a>6. 超分辨率</h2><p>提高原始图像的分辨率，从低分辨率图片中生成丢失的高频细节来提高图像或视频的分辨率。目标是生成比输入图像分辨率更高的输出图像，同时保留原始内容和结构。</p><p><img src="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87.jpg" alt="超分辨率"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> CV基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用TensorBoard进行可视化</title>
      <link href="/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TensorBoard介绍"><a href="#1-TensorBoard介绍" class="headerlink" title="1. TensorBoard介绍"></a>1. TensorBoard介绍</h2><p><a href="https://www.tensorflow.org/tensorboard?hl=zh-cn">TensorBoard</a>是TensorFlow推出的可视化工具，可以可视化模型结构、跟踪并以表格形式显示模型指标。</p><p>TensorBoard的使用包括两个步骤：</p><ol><li>在代码中设置TensorBoard，在训练的过程中将会根据设置产生日志文件</li><li>在浏览器中可视化该日志文件，查看网络结构、loss的变化情况等</li></ol><p>下面以 <code>LeNet-5</code> 为例，介绍如何在TensorFlow和PyTorch中配置TensorBoard。</p><h2 id="2-代码中设置TensorBoard"><a href="#2-代码中设置TensorBoard" class="headerlink" title="2. 代码中设置TensorBoard"></a>2. 代码中设置TensorBoard</h2><h3 id="2-1-TensorFlow中设置"><a href="#2-1-TensorFlow中设置" class="headerlink" title="2.1 TensorFlow中设置"></a>2.1 TensorFlow中设置</h3><h4 id="2-1-1-使用说明"><a href="#2-1-1-使用说明" class="headerlink" title="2.1.1 使用说明"></a>2.1.1 使用说明</h4><p>在TensorFlow通过两个简单步骤即可使用TensorBoard（更多的功能可参考<a href="https://www.tensorflow.org/tensorboard/get_started?hl=zh-cn">官方文档</a>）。</p><ol><li><p><code>tensorboard_callback = keras.callbacks.TensorBoard(log_dir=&#39;logs/tf&#39;)</code> ：初始化日志文件。其中，<code>log_dir</code> 是日志文件的存放位置</p></li><li><p><code>model.fit(callbacks=[tensorboard_callback])</code> ：设置回调函数，在模型训练期间将会调用 <code>tensorboard_callback</code> 从而向日志文件中写入数据</p><p>注意：</p><p><strong>日志文件的绝对路径中不能包含中文</strong>！</p></li></ol><h4 id="2-1-2-代码实现"><a href="#2-1-2-代码实现" class="headerlink" title="2.1.2 代码实现"></a>2.1.2 代码实现</h4><p><code>LeNet-5</code> 的搭建可参考<a href="/2023/08/05/TensorFlow%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">TensorFlow搭建神经网络</a></p><pre><code class="python">import timeimport tensorflow as tffrom keras import datasetsfrom keras import layersfrom tensorflow import kerasdef my_model(input_shape):    # 首先，创建一个输入节点    inputs = keras.Input(input_shape)    # 搭建神经网络    x = layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(inputs)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(x)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Flatten()(x)    x = layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;)(x)    x = layers.Dense(units=120, activation=&#39;relu&#39;)(x)    # 输出层    outputs = layers.Dense(units=10, activation=&#39;softmax&#39;)(x)    model = keras.Model(inputs=inputs, outputs=outputs)    return model(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()train_images = tf.reshape(train_images, (train_images.shape[0], train_images.shape[1], train_images.shape[2], 1))train_images = tf.cast(train_images, tf.float32)test_images = tf.reshape(test_images, (test_images.shape[0], test_images.shape[1], test_images.shape[2], 1))test_images = tf.cast(test_images, tf.float32)model = my_model(train_images.shape[1:])loss = keras.losses.SparseCategoricalCrossentropy()optimizer = keras.optimizers.SGD(0.0001)model.compile(loss=loss, optimizer=keras.optimizers.SGD(0.00001))# 初始化日志文件tensorboard_callback = keras.callbacks.TensorBoard(    log_dir=&#39;logs/tf/&#39; + time.strftime(&#39;%m-%d-%H-%M&#39;, time.localtime(time.time())))# 在训练过程中设置回调model.fit(train_images, train_labels, validation_split=0.3, epochs=1000, batch_size=20,          callbacks=[tensorboard_callback])pre_labels = model.predict(test_images)</code></pre><h3 id="2-2-PyTorch中设置"><a href="#2-2-PyTorch中设置" class="headerlink" title="2.2 PyTorch中设置"></a>2.2 PyTorch中设置</h3><h4 id="2-2-1-使用说明"><a href="#2-2-1-使用说明" class="headerlink" title="2.2.1 使用说明"></a>2.2.1 使用说明</h4><p>PyTorch1.1之后添加了TensorBoard，在PyTorch中使用TensorBoard主要有3个步骤（具体信息可查看其<a href="https://pytorch.org/docs/stable/tensorboard.html#torch.utils.tensorboard.writer.SummaryWriter.__init__">官方文档</a>）：</p><ol><li><code>SummaryWriter</code> ：创建一个日志文件，主要有以下两个参数：<ul><li><code>log_dir</code> ：保存日志文件的目录，默认值为 <code>runs/当前日期时间</code> （<strong>存放的路径中不能包含中文</strong>！）</li><li><code>comment</code> ： <code>log_dir</code> 取默认值时添加到 <code>log_dir</code> 后面的后缀，当设置了 <code>log_dir</code>  时，该值无效</li></ul></li><li><code>add_XXX</code>： 向创建好的日志文件里面添加数据，常用的有：<ul><li><code>add_graph</code> ：添加GRAPHS，其中存放了网络结构。有以下两个常用参数：<ul><li><code>model</code> ：模型</li><li><code>input_to_model</code> ：模型的输入数据</li></ul></li><li><code>add_scalar</code> ： 添加SCALARS，其中可以存放折线图数据用于显示训练过程中的损失值变化情况。有以下三个常用参数：<ul><li><code>tag</code> ：折线图的标签。指定tag时，加入 <code>/</code> 分割，<strong>可将多个折线图放在一个tag下</strong>，如 ：<code>tag=train/loss, tag=train/map</code>，此时train下面会有loss和map两个折线图</li><li><code>scalar_value</code> ：折线图纵轴的值，一般是loss、准确率等数据</li><li><code>global_step</code> ：折线图的横轴，一般是epoch</li></ul></li><li><code>add_scalars</code> ：在一张折线图中同时绘制多个数据，有以下三个常用参数：<ul><li><code>main_tag,</code> ：与 <code>add_scalar</code> 中的 <code>tag</code> 用法一样</li><li><code>tag_scalar_dict</code> ：纵轴的值，因为是多个数据，需要以字典形式传入（具体看下面代码实现）</li><li><code>global_step</code> ：与 <code>add_scalar</code> 中的 <code>global_setp</code> 用法一样</li></ul></li></ul></li><li><code>close</code>：结束log写入，一般用在训练结束后</li></ol><p>类似于操作文件，<code>SummaryWriter</code> 也可以和 <code>with</code> 一起使用，此时可以不需显示调用 <code>close</code> ，如：</p><pre><code class="python">writer = SummaryWriter()# 写入数据……writer.close()#上面的代码等价于下面with SummaryWriter() as w:    # 写入数据……</code></pre><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p><code>LeNet-5</code> 的搭建可参考<a href="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">PyTorch搭建神经网络</a></p><pre><code class="python">import timeimport torchimport torch.nn as nnimport torch.nn.functional as Fimport torchvisionfrom sklearn.metrics import classification_reportfrom torch import optimfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transformsfrom tqdm import tqdmclass LeNet(nn.Module):    def __init__(self, in_channels):        super(LeNet, self).__init__()        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1)        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)        self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(in_features=16 * 4 * 4, out_features=120)        self.fc2 = nn.Linear(in_features=120, out_features=84)        self.fc3 = nn.Linear(in_features=84, out_features=10)    def forward(self, x):        x = self.conv1(x)        x = F.relu(x)        x = self.pool1(x)        x = self.conv2(x)        x = F.relu(x)        x = self.pool2(x)        x = x.reshape(x.shape[0], -1)        x = self.fc1(x)        x = F.relu(x)        x = self.fc2(x)        x = F.relu(x)        x = self.fc3(x)        return xdef main():    batch_size = 8    num_epochs = 10    train_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=True, transform=transforms.ToTensor(),                                               download=True)    val_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=False, transform=transforms.ToTensor(), download=True)    train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size,                              shuffle=True)    val_loader = DataLoader(dataset=val_dataset, batch_size=batch_size, shuffle=True)    device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)    model = LeNet(1).to(device)    criterion = nn.CrossEntropyLoss()    optimizer = optim.Adam(model.parameters())    writer = SummaryWriter(        &#39;logs/pt/&#39; + time.strftime(&#39;%m-%d-%H-%M&#39;, time.localtime(time.time())))  # 设置了存放位置，此时即使设置了 comment 也不起作用    writer.add_graph(model, torch.randn(1, 1, 28, 28))  # 先写入模型结构    for epoch in tqdm(range(num_epochs)):        train_loss = 0        val_loss = 0        accuracy = 0        macro_avg_f1 = 0        weighted_avg_f1 = 0        # 训练模型        for batch_idx, (data, label) in enumerate(train_loader):            data = data.to(device=device)            label = label.to(device=device)            pre = model(data)            loss = criterion(pre, label)            train_loss = (train_loss * batch_idx + loss) / (batch_idx + 1)            optimizer.zero_grad()            loss.backward()            optimizer.step()        # 评估模型        with torch.no_grad():            model.eval()            for batch_idx, (data, label) in enumerate(val_loader):                data = data.to(device=device)                label = label.to(device=device)                pre = model(data)                loss = criterion(pre, label).item()                val_loss = (val_loss * batch_idx + loss) / (batch_idx + 1)                pre = torch.argmax(pre, dim=1)                score = classification_report(pre, label, output_dict=True)                accuracy = (accuracy * batch_idx + score[&#39;accuracy&#39;]) / (batch_idx + 1)                macro_avg_f1 = (macro_avg_f1 * batch_idx + score[&#39;macro avg&#39;][&#39;f1-score&#39;]) / (batch_idx + 1)                weighted_avg_f1 = (weighted_avg_f1 * batch_idx + score[&#39;weighted avg&#39;][&#39;f1-score&#39;]) / (batch_idx + 1)            model.train()        writer.add_scalar(&#39;val/accuracy&#39;, accuracy, epoch)  # 在一个 tag 下面添加多个折线图        writer.add_scalar(&#39;val/macro avg-f1&#39;, macro_avg_f1, epoch)        writer.add_scalar(&#39;val/weighted avg-f1&#39;, weighted_avg_f1, epoch)        writer.add_scalars(&#39;loss&#39;, &#123;&#39;train_loss&#39;: train_loss, &#39;val_loss&#39;: val_loss&#125;, epoch)  # 一个折线图里面显示多个数据    writer.close()  # 训练结束，不再写入数据，关闭writerif __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="3-可视化"><a href="#3-可视化" class="headerlink" title="3. 可视化"></a>3. 可视化</h2><p>注意，这里如果直接输入tensorboard使用的是系统python环境里面的tensorboard，因此，<strong>务必确保系统python环境中已安装了tensorboard</strong>。</p><p>打开 <code>log</code> 所在的文件夹，在该文件夹下打开命令行窗口（1.在路径显示框中输入 <code>cmd</code> 然后回车即可打开 或者 2. 在文件夹中按住 <code>Shift</code> 键同时右击鼠标然后选择‘在此处打开Powershell窗口’），输入：</p><pre><code class="shell">tensorboard --logdir=.\logs --port=6007</code></pre><p>其中：</p><ul><li>–logdir：存放日志文件的文件夹</li><li>–port：端口号，默认是6006</li></ul><p>若正常，将显示以下信息：</p><p><img src="/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/1.jpg" alt="1"></p><p>打开浏览器，在地址栏中输入：<strong>localhost:6007</strong>（端口号要和上面保持一致）。即可看到可视化的效果，点击不同的标签可查看不同数据</p><p><img src="/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/2.jpg" alt="2"></p><h2 id="4-配合远程服务器使用"><a href="#4-配合远程服务器使用" class="headerlink" title="4. 配合远程服务器使用"></a>4. 配合远程服务器使用</h2><p>上面的代码和浏览器都在同一个电脑上，有时需要在服务器上跑代码，这时候要想在自己的电脑浏览器上可视化TensorBoard，可以按照下面的方式：</p><h3 id="4-1-端口转发"><a href="#4-1-端口转发" class="headerlink" title="4.1 端口转发"></a>4.1 端口转发</h3><p>在电脑命令行窗口输入：</p><pre><code class="shell">ssh -L 6008:127.0.0.1:6007 服务器用户名@服务器IP地址 -p 22</code></pre><p>这将在连接服务器的同时将服务器上的 <strong>6007</strong> 端口转发到本地的 <strong>6008</strong> 端口。</p><p>成功连接服务器后，按照上面讲的可视化的方法在服务器对应的目录下输入：</p><pre><code class="shell">tensorboard --logdir=日志文件的存放路径 --port=6007</code></pre><p>成功启动后，在电脑的浏览器中输入：<strong>localhost:6008</strong> 。这里用到了两个端口号，一个是服务器上tensorboard使用的端口号 6007 ，一个是本地转发以及浏览器使用的端口号 6008 ，注意区分。</p><h3 id="4-2-Xshell建立隧道"><a href="#4-2-Xshell建立隧道" class="headerlink" title="4.2 Xshell建立隧道"></a>4.2 Xshell建立隧道</h3><p>在Xshell中选择需要设置的会话，然后右键选择属性，进行如下设置</p><p><img src="/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/3.jpg" alt="3"></p><p><img src="/2023/08/05/%E4%BD%BF%E7%94%A8TensorBoard%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96/4.jpg" alt="4"></p><p>设置完之后连接服务器，在服务器对应的目录下输入：</p><pre><code class="shell">tensorboard --logdir=日志文件的存放路径 --port=6007</code></pre><p>成功启动后，在电脑的浏览器中输入：<strong>localhost:6008</strong> 。这里用到了两个端口号，一个是服务器上tensorboard使用的端口号 6007 ，一个是浏览器使用的端口号 6008 ，注意区分。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> TensorBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow搭建神经网络</title>
      <link href="/2023/08/05/TensorFlow%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/08/05/TensorFlow%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>TensorFlow版本：2.13.0</li><li><a href="https://www.tensorflow.org/guide">TensorFlow官方文档</a></li><li><a href="https://www.tensorflow.org/guide?hl=zh-cn">TensorFlow官方文档中文版</a></li></ul><p>TensorFlow中搭建并训练一个神经网络分为以下几步：</p><ol><li>定义神经网络</li><li>配置损失函数以及优化器</li><li>训练：反向传播、梯度下降</li></ol><p>下面以LeNet-5为例，搭建一个卷积神经网络用于手写数字识别。（LeNet-5以及MNIST数据集介绍见<a href="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">PyTorch搭建神经网络</a>）</p><h2 id="1-定义神经网络"><a href="#1-定义神经网络" class="headerlink" title="1. 定义神经网络"></a>1. 定义神经网络</h2><p>TensorFlow提供了三种构建神经网络的方法，分别是继承Model类自定义模型、序列式以及函数式。</p><h3 id="1-1-继承Model类自定义"><a href="#1-1-继承Model类自定义" class="headerlink" title="1.1 继承Model类自定义"></a>1.1 继承Model类自定义</h3><ul><li>继承 <code>keras.Model</code> 类</li><li>重写父类的 <code>call</code> 方法，该方法负责前向计算</li></ul><p>例如：</p><pre><code class="python">from keras import layersfrom tensorflow import kerasclass MyModel(keras.Model):    def __init__(self):        super(MyModel, self).__init__()        self.conv1 = layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)        self.pool1 = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))        self.conv2 = layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)        self.pool2 = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))        self.fc1 = layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;)        self.fc2 = layers.Dense(units=120, activation=&#39;relu&#39;)        self.fc3 = layers.Dense(units=10, activation=&#39;softmax&#39;)    def call(self, x):        x = self.conv1(x)        x = self.pool1(x)        x = self.conv2(x)        x = self.pool2(x)        x = layers.Flatten()(x)  # 二维压缩成一维        x = self.fc1(x)        x = self.fc2(x)        x = self.fc3(x)        return x</code></pre><h3 id="1-2-序列式"><a href="#1-2-序列式" class="headerlink" title="1.2 序列式"></a>1.2 序列式</h3><ul><li>该方式适用于简单的层堆栈，其中每一层恰好有一个输入张量和一个输出张量</li><li>在以下情况下不适合使用该方法：<ul><li>模型有多个输入或多个输出</li><li>任何层都有多个输入或多个输出</li><li>需要进行图层共享</li><li>想要非线性拓扑（如残差连接、多分支模型）</li></ul></li></ul><p>例如：</p><pre><code class="python">from keras import layersfrom tensorflow import kerasdef my_model():    model = keras.Sequential()    model.add(layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;))    model.add(layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2)))    model.add(layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;))    model.add(layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2)))    model.add(layers.Flatten())    model.add(layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;))    model.add(layers.Dense(units=120, activation=&#39;relu&#39;))    model.add(layers.Dense(units=10, activation=&#39;softmax&#39;))    # 另一种堆叠神经网络的方式    &#39;&#39;&#39;    model = keras.Sequential(        [            layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;),            layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2)),            layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;),            layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2)),            layers.Flatten(),            layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;),            layers.Dense(units=120, activation=&#39;relu&#39;),            layers.Dense(units=10, activation=&#39;softmax&#39;),        ]    )    &#39;&#39;&#39;    return model</code></pre><h3 id="1-3-函数式"><a href="#1-3-函数式" class="headerlink" title="1.3 函数式"></a>1.3 函数式</h3><ul><li>该方法<strong>允许多个输入、多个输出、分支和层共享</strong>，是构建Keras模型最流行的方法</li><li>深度学习的模型通常是由层 (layers) 组成的有向无环图，而函数式就是构建这种图的一种有效方式</li><li>该方法:<ul><li>需要单独定义输入</li><li>然后，需要创建一个输出对象，同时创建所有层，这些层相互关联并与输出相关联</li><li>最后，创建一个接受输入和输出作为参数的模型对象</li></ul></li></ul><p>例如：</p><pre><code class="python">from keras import layersfrom tensorflow import kerasdef my_model(input_shape):    # 首先，创建一个输入节点    inputs = keras.Input(input_shape)    # 搭建神经网络    x = layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(inputs)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(x)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Flatten()(x)    x = layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;)(x)    x = layers.Dense(units=120, activation=&#39;relu&#39;)(x)    # 输出层    outputs = layers.Dense(units=10, activation=&#39;softmax&#39;)(x)    model = keras.Model(inputs=inputs, outputs=outputs)    return model</code></pre><h2 id="2-配置损失函数以及优化器"><a href="#2-配置损失函数以及优化器" class="headerlink" title="2. 配置损失函数以及优化器"></a>2. 配置损失函数以及优化器</h2><ul><li><p>损失函数</p><p>损失函数用于计算真实值和预测值之间的差异。在<a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses">TensorFlow官方文档</a>中，给出了可用的损失函数列表。</p><p>这里，我们使用交叉熵损失函数<strong>keras.losses.SparseCategoricalCrossentropy</strong>。该损失函数有一个参数<code>from_logits</code> ，该参数<strong>决定是否对预测值进行Softmax</strong>，默认值为 <code>false</code> 。</p></li><li><p>优化器</p><p>优化器根据损失函数求出的损失，对神经网络的参数进行更新。在<a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers">TensorFlow官方文档</a>中，给出了可用的优化器。这里，我们使用<strong>keras.optimizers.SGD</strong>作为我们的优化器。</p></li></ul><pre><code class="python">from tensorflow import kerasloss = keras.losses.SparseCategoricalCrossentropy()  # 预测值已Softmax，from_logits 取默认值optimizer = keras.optimizers.SGD(0.0001)</code></pre><h2 id="3-训练以及测试模型"><a href="#3-训练以及测试模型" class="headerlink" title="3. 训练以及测试模型"></a>3. 训练以及测试模型</h2><h3 id="3-1训练模型"><a href="#3-1训练模型" class="headerlink" title="3.1训练模型"></a>3.1训练模型</h3><p>模型训练只需在配置好训练参数后调用 <code>fit</code> 函数即可，该函数会自动进行前向计算、反向传播、梯度下降。</p><p>如：</p><pre><code class="python"># 加载数据集(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()# 维度调整，增加一个维度代表通道数# 卷积神经网络的输入数据是4维的，分别代表: batch size，图片高度、宽度、通道数# 批量大小在训练时指定，因此输入的数据应该是3维的，分别代表：图片高度、宽度、通道数train_images = tf.reshape(train_images, (train_images.shape[0], train_images.shape[1], train_images.shape[2], 1))train_images = tf.cast(train_images, tf.float32)test_images = tf.reshape(test_images, (test_images.shape[0], test_images.shape[1], test_images.shape[2], 1))test_images = tf.cast(test_images, tf.float32)model = my_model(train_images.shape[1:])# 配置神经网络，设置损失函数、优化器loss = keras.losses.SparseCategoricalCrossentropy()  # 预测值已Softmax，from_logits 取默认值optimizer = keras.optimizers.SGD(0.0001)model.compile(loss=loss, optimizer=keras.optimizers.SGD(0.00001))# 训练神经网络，设置训练集与验证集的比例、迭代次数、batch size等model.fit(train_images, train_labels, validation_split=0.3, epochs=1000, batch_size=20)</code></pre><p>注：</p><p>TensorFlow会自动决定是使用GPU还是CPU，<strong>默认情况下优先使用GPU</strong>。</p><h3 id="3-2-测试模型"><a href="#3-2-测试模型" class="headerlink" title="3.2 测试模型"></a>3.2 测试模型</h3><p>模型训练只需调用 <code>predict</code> 函数即可。</p><pre><code>pre_labels = model.predict(test_images)</code></pre><h2 id="4-整体代码"><a href="#4-整体代码" class="headerlink" title="4. 整体代码"></a>4. 整体代码</h2><pre><code class="python">import tensorflow as tffrom keras import datasetsfrom keras import layersfrom tensorflow import kerasdef my_model(input_shape):    # 首先，创建一个输入节点    inputs = keras.Input(input_shape)    # 搭建神经网络    x = layers.Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(inputs)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation=&#39;relu&#39;)(x)    x = layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)    x = layers.Flatten()(x)    x = layers.Dense(units=16 * 4 * 4, activation=&#39;relu&#39;)(x)    x = layers.Dense(units=120, activation=&#39;relu&#39;)(x)    # 输出层    outputs = layers.Dense(units=10, activation=&#39;softmax&#39;)(x)    model = keras.Model(inputs=inputs, outputs=outputs)    return model# 加载数据集(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()# 维度调整，增加一个维度代表通道数# 卷积神经网络的输入数据是4维的，分别代表: batch size，图片高度、宽度、通道数# 批量大小在训练时指定，因此输入的数据应该是3维的，分别代表：图片高度、宽度、通道数train_images = tf.reshape(train_images, (train_images.shape[0], train_images.shape[1], train_images.shape[2], 1))train_images = tf.cast(train_images, tf.float32)test_images = tf.reshape(test_images, (test_images.shape[0], test_images.shape[1], test_images.shape[2], 1))test_images = tf.cast(test_images, tf.float32)model = my_model(train_images.shape[1:])# 配置神经网络，设置损失函数、优化器loss = keras.losses.SparseCategoricalCrossentropy()  # 预测值已Softmax，from_logits 取默认值optimizer = keras.optimizers.SGD(0.0001)model.compile(loss=loss, optimizer=keras.optimizers.SGD(0.00001))# 训练神经网络，设置训练集与验证集的比例、迭代次数、batch size等model.fit(train_images, train_labels, validation_split=0.3, epochs=1000, batch_size=20)pre_labels = model.predict(test_images)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> TensorFlow入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型6——类型擦除</title>
      <link href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
      <url>/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-什么是类型擦除"><a href="#1-什么是类型擦除" class="headerlink" title="1. 什么是类型擦除"></a>1. 什么是类型擦除</h2><p>泛型是在Java 1.5被引进的，但是泛型代码可以和之前的版本兼容，原因就是泛型只存在代码编译阶段，编译后的字节码中（也就是运行时）不包含泛型中的类型信息。<strong>使用泛型时，泛型相关的类型参数信息会在编译时被擦除掉，这个过程被称为类型擦除</strong>。比如：</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;Integer&gt; i = new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; s = new LinkedList&lt;&gt;();        System.out.println(&quot;i:&quot; + i.getClass());        System.out.println(&quot;s:&quot; + s.getClass());    &#125;&#125;</code></pre><p><img src="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/1.jpg" alt="1"></p><p>从运行结果可以看到，虽然为 <code>i</code> 和 <code>s</code> 指定了不同的类型参数，但在运行时它们实际上是同一种类型（都是 <code>LinkedList</code> ）。这就是类型擦除的作用，在编译时将代码中的类型参数擦除<strong>只保留原始类型</strong>。</p><h2 id="2-原始类型"><a href="#2-原始类型" class="headerlink" title="2. 原始类型"></a>2. 原始类型</h2><p>原始类型是擦除了泛型信息后字节码中的类型，无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。<strong>类型参数信息被擦除只会保留原始类型</strong>。根据是否限定类型，原始类型替换有以下两种情况：</p><h3 id="2-1-无限定类型"><a href="#2-1-无限定类型" class="headerlink" title="2.1 无限定类型"></a>2.1 无限定类型</h3><p>将类型参数替换为<code>Object</code>。例如：</p><pre><code class="jade">class Test&lt;T&gt; &#123;    private T value;    public T getValue() &#123;        return value;    &#125;    public void setValue(T value) &#123;        this.value = value;    &#125;&#125;</code></pre><p>类型擦除后：</p><pre><code class="java">class Test &#123;    private Object value;    public Object getValue() &#123;        return value;    &#125;    public void setValue(Object value) &#123;        this.value = value;    &#125;&#125;</code></pre><h3 id="2-2-有限定类型"><a href="#2-2-有限定类型" class="headerlink" title="2.2 有限定类型"></a>2.2 有限定类型</h3><p>将类型参数替换为<strong>上限或下限</strong>。例如：</p><pre><code class="java">class Test&lt;T extends Number&gt; &#123;    private T value;&#125;</code></pre><p>类型擦除后：</p><pre><code class="java">class Test &#123;    private Number value;&#125;</code></pre><h2 id="3-类型擦除原理"><a href="#3-类型擦除原理" class="headerlink" title="3. 类型擦除原理"></a>3. 类型擦除原理</h2><p>Java在编译时进行泛型的类型擦除，但在进行类型擦除时会将传入的类型参数记录下来。当对被擦除后的泛型对象操作时编译器会<strong>根据记录的类型参数对其进行类型转换</strong>，将其从原始类型转换为未传入的参数类型。</p><h2 id="4-类型擦除带来的问题"><a href="#4-类型擦除带来的问题" class="headerlink" title="4. 类型擦除带来的问题"></a>4. 类型擦除带来的问题</h2><p>主要有以下几点（部分问题在之前已经说过了，如泛型变量不能是基本数据类型，具体内容可参考<a href="https://blog.csdn.net/swadian2008/article/details/100546069">CSDN博客</a>）：</p><ul><li>引用传递问题</li><li>自动类型转换问题</li><li>类型擦除与多态冲突</li><li>泛型变量不能是基本数据类型</li><li>运行时类型检查异常</li><li>泛型异常捕获</li><li>不能创建泛型类型数组</li><li>不能实例化泛型类型</li><li>类型擦除后的冲突</li><li>不能使用静态域</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型5——泛型通配符</title>
      <link href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-什么是通配符"><a href="#1-什么是通配符" class="headerlink" title="1. 什么是通配符"></a>1. 什么是通配符</h2><p>在Java中，类与类之间是有继承关系的。例如，<code>Integer</code> 类继承自 <code>Number</code> 类，因此<code>Integer</code> 类的对象可以赋值给 <code>Number</code> 类的引用（即<strong>向上转型</strong>，这是可以实现<strong>多态性</strong>的一个重要因素）。但集合之间没有这种关系，也就是 <code>LinkedList&lt;Integer&gt;</code> 和  <code>LinkedList&lt;Number&gt;</code>之间并没有继承关系，<strong>它们都是<code>LinkedList</code> 类</strong>。因此  <code>LinkedList&lt;Number&gt;</code> 的集合并不能存放<code>Integer</code> 类型的变量（虽然<code>Integer</code> 类继承自 <code>Number</code> 类）。</p><p>比如下面这段代码：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;Father&gt; test) &#123;        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; tesF = new Test&lt;&gt;();        Test&lt;Child&gt; testC = new Test&lt;&gt;();        Main.dealTest(tesF);        Main.dealTest(testC);//编译器报错    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>这段代码定义了一个泛型类 <code>Test</code> ，并定义了一个处理该类的静态方法 <code>dealTest()</code>，该类接受一个 <code>Test&lt;Father&gt;</code> 对象作为参数。根据上面的介绍可以知道，虽然<code>Child</code> 是  <code>Father</code> 的子类，但<code>Test&lt;Child&gt;</code> 和 <code>Test&lt;Father&gt;</code> 之间并没有继承关系，因此静态方法 <code>dealTest()</code>不能接受一个 <code>Test&lt;Son&gt;</code> 对象。因此，若想让静态方法 <code>dealTest()</code>处理<code>Test&lt;Son&gt;</code> 对象，还需对其进行重载：</p><pre><code class="java">private static void dealTest(Test&lt;Child&gt; test) &#123;    &#125;</code></pre><p>但这显然违背了多态性的设计理念，而且<strong>这是编译器不允许的做法</strong>。如果能让 <code>dealTest()</code>方法不只接受<code>Test&lt;Father&gt;</code>对象，而是让其接受<code>Test&lt;XXX&gt;</code>对象，其中<strong>XXX代表某一类型内的类型参数</strong>，那么上面这个问题就可以解决了。</p><p>这就是泛型通配符的作用：<strong>泛型通配符用于限制类型参数的范围。</strong></p><p>泛型通配符有 3 种形式：</p><ul><li><?> ：无界通配符</li><li><? extends T> ：有上界的通配符</li><li><? super T> ：有下界的通配符</li></ul><h2 id="2-无界通配符"><a href="#2-无界通配符" class="headerlink" title="2. 无界通配符"></a>2. 无界通配符</h2><h3 id="2-1-无界通配符的定义和使用"><a href="#2-1-无界通配符的定义和使用" class="headerlink" title="2.1 无界通配符的定义和使用"></a>2.1 无界通配符的定义和使用</h3><p>无界通配符：<code>&lt;?&gt;</code>，其中 <strong>?</strong> 代表了任意一种数据类型。比如，下面这段代码：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;?&gt; test) &#123;//?代表可以使用任意一种数据类型        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; tesF = new Test&lt;&gt;();        Test&lt;Child&gt; testC = new Test&lt;&gt;();        Test&lt;Integer&gt; testI = new Test&lt;&gt;();        Main.dealTest(tesF);        Main.dealTest(testC);        Main.dealTest(testI);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><p>由于使用了无界通配符，<code>dealTest()</code>方法可以接受具有不同泛型参数的泛型类 <code>Test</code>的对象。</p><h3 id="2-2-无界通配符注意事项"><a href="#2-2-无界通配符注意事项" class="headerlink" title="2.2 无界通配符注意事项"></a>2.2 无界通配符注意事项</h3><ul><li><p>不要混淆 <code>Test&lt;Object&gt;</code>  和  <code>Test&lt;?&gt;</code> ，<code>Object</code> 也是一种数据类型，因此 <strong><code>Test&lt;Object&gt;</code> 代表参数类型只能为<code>Object</code>的<code>Test</code>类</strong>， <code>Test&lt;?&gt;</code>代表参数类型可以是任意数据类型的<code>Test</code>类</p></li><li><p><strong>不要在实例化泛型类的时候使用无界通配符</strong>，<code>&lt;?&gt;</code> 集合的数据类型是不确定的，因此我们只能往集合中添加<code>null</code>，而且从其中取出的元素也只能赋值给<code>Object</code>对象<strong>（无界通配符不能写也不能读）</strong></p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;?&gt; list = new LinkedList&lt;&gt;();        list.add(null);        list.add(1);//编译器报错，只能放入null    &#125;&#125;</code></pre></li></ul><h2 id="2-上界通配符"><a href="#2-上界通配符" class="headerlink" title="2. 上界通配符"></a>2. 上界通配符</h2><h3 id="2-1-上界通配符的定义和使用"><a href="#2-1-上界通配符的定义和使用" class="headerlink" title="2.1 上界通配符的定义和使用"></a>2.1 上界通配符的定义和使用</h3><p>上界通配符：<code>&lt;? extends T&gt;</code>，其中<strong>T</strong> 代表了类型参数的上界。上界通配符将类型参数限制为特定类型<strong>T</strong>及其子类型。比如，<code>&lt;? extends Number&gt;</code>表示类型参数可以是<code>Number</code>以及<code>Number</code>的子类。</p><p>可以使用上界通配符对上面的代码进行改写：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;? extends Father&gt; test) &#123;//&lt;? extends Father&gt; 代表可以使用 Father 及其子类作为类型参数        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; fatherTest = new Test&lt;&gt;();        Test&lt;Child&gt; childTest = new Test&lt;&gt;();        Main.dealTest(fatherTest);        Main.dealTest(childTest);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><h3 id="2-2-上界通配符使用场景"><a href="#2-2-上界通配符使用场景" class="headerlink" title="2.2 上界通配符使用场景"></a>2.2 上界通配符使用场景</h3><p>上界通配符可以用于定义泛型类、泛型接口、泛型方法（注意是定义<strong>泛型方法</strong>）以及声明变量</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    private static &lt;T extends Number&gt; void dealTest(T t) &#123;//定义泛型方法    &#125;    public static void main(String[] args) &#123;        LinkedList&lt;? extends Number&gt; list1 = new LinkedList&lt;Integer&gt;();//声明变量    &#125;&#125;class TestClass&lt;T extends Number&gt; &#123;//定义泛型类&#125;interface TestInterface&lt;T extends Number&gt; &#123;//定义泛型接口&#125;</code></pre><h3 id="2-3-上界通配符只能读不能写"><a href="#2-3-上界通配符只能读不能写" class="headerlink" title="2.3 上界通配符只能读不能写"></a>2.3 上界通配符只能读不能写</h3><p>以 <code>LinkedList&lt;? extends Number&gt;</code> 为例，在使用上界通配符的时候需要注意：</p><p> <code>LinkedList&lt;? extends Number&gt;</code> 可以代表 <code>LinkedList&lt;? extends Interger&gt;</code>、 <code>LinkedList&lt;? extends Double&gt;</code>……但是，不能指定 <code>LinkedList&lt;? extends Number&gt;</code>的数据类型。</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();        list.add(10);        LinkedList&lt;? extends Number&gt; list1 = list;                list1.get(0);//上界通配符可以读        list1.add(20);//编译器报错，上界通配符不可以写        list1.add(null);//可以写入null    &#125;&#125;</code></pre><p>在看上面的代码之前，需要明确一个概念，那就是 <strong><code>LinkedList&lt;? extends Number&gt;</code>表示这个集合可能是 <code>LinkedList&lt;? extends Interger&gt;</code>也可能是 <code>LinkedList&lt;? extends Double&gt;</code>，但它什么都可能是的后果就是它什么也不是，也就是说不能确定它到底是 <code>LinkedList&lt;? extends Interger&gt;</code>还是 <code>LinkedList&lt;? extends Double&gt;</code>或者其他什么集合</strong>，所以也就<strong>不能往里面添加具体类型的元素</strong>，因为不能确定它是什么类型的。但和无界通配符类似，可以往里面添加<code>null</code>。</p><h2 id="3-下界通配符"><a href="#3-下界通配符" class="headerlink" title="3. 下界通配符"></a>3. 下界通配符</h2><h3 id="3-1-下界通配符的定义和使用"><a href="#3-1-下界通配符的定义和使用" class="headerlink" title="3.1 下界通配符的定义和使用"></a>3.1 下界通配符的定义和使用</h3><p>下界通配符：<code>&lt;? super T&gt;</code>，与上界通配符刚好相反，T代表了类型参数的下界。类似地，下界通配符将类型参数限制为特定类型<strong>T</strong>及其超类。比如，<code>&lt;? extends Integer&gt;</code>表示类型参数可以是<code>Integer</code>以及<code>Integer</code>的超类。</p><p>可以使用下界通配符对上面的代码进行改写：</p><pre><code class="java">public class Main &#123;    private static void dealTest(Test&lt;? super Child&gt; test) &#123;//&lt;? super Child&gt; 代表可以使用 Child 及其超类作为类型参数        System.out.println(test.getClass());    &#125;    public static void main(String[] args) &#123;        Test&lt;Father&gt; fatherTest = new Test&lt;&gt;();        Test&lt;Child&gt; childTest = new Test&lt;&gt;();        Main.dealTest(fatherTest);        Main.dealTest(childTest);    &#125;&#125;class Father &#123;&#125;class Child extends Father &#123;&#125;class Test&lt;T&gt; &#123;&#125;</code></pre><h3 id="3-2-下界通配符使用场景"><a href="#3-2-下界通配符使用场景" class="headerlink" title="3.2 下界通配符使用场景"></a>3.2 下界通配符使用场景</h3><p>下界通配符只可以用于声明变量，不可以用于定义泛型类、泛型接口、泛型方法（注意是定义<strong>泛型方法</strong>）。</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    private static &lt;T super Number&gt; void dealTest() &#123;//编译器报错，不可以用于定义泛型方法    &#125;    private static void dealTest(TestClass&lt;? super Number&gt; t) &#123;//注意，这不是泛型方法    &#125;    public static void main(String[] args) &#123;        LinkedList&lt;? super Number&gt; list1 = new LinkedList&lt;Number&gt;();//声明变量    &#125;&#125;class TestClass&lt;T super Number&gt;&#123;//编译器报错，不可以用于定义泛型类&#125;interface TestInterface&lt;T super Number&gt;&#123;//编译器报错，不可以用于定义泛型接口&#125;</code></pre><h3 id="3-3-下界通配符只能写不能读"><a href="#3-3-下界通配符只能写不能读" class="headerlink" title="3.3 下界通配符只能写不能读"></a>3.3 下界通配符只能写不能读</h3><p>上界通配符只能读不能写，而下界通配符正好相反，可以写但不能读。</p><p><strong>带有下界通配符的集合<code>LinkedList&lt;? super Number&gt;</code>可以添加<code>Number</code>类及其子类的对象</strong>。因为<code>LinkedList&lt;? extends Number&gt;</code>最低也是个<code>LinkedList&lt;Number extends Number&gt;</code>集合，因此至少也能存放<code>Number</code>类对象，所以也可以存放<code>Number</code>子类对象。但是<code>LinkedList&lt;? extends Number&gt;</code>的上限不知道，所以类似于带有上界通配符的集合不能存放具体的数据类型，<code>LinkedList&lt;? extends Number&gt;</code>不能存放<code>Number</code>父类的对象。</p><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;? super Integer&gt; list = new LinkedList&lt;Number&gt;();        list.add(10);//下界通配符可以写        list.add((Object) 2.5);//编译器报错，不能存放 Integer 类的父类对象        Object a = list.get(0);//可以赋值给 Objedct 类型的对象        int b = list.get(0);//编译器报错，不能赋值给除 Object 类外的其他类的对象    &#125;&#125;</code></pre><p>下界通配符获取到的元素不能赋值给具体的类型（原因和上界通配符只能读不能写类似），但和无界通配符类似，<strong>可以赋值给<code>Object</code>对象</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型4——泛型方法</title>
      <link href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-定义泛型方法"><a href="#1-定义泛型方法" class="headerlink" title="1. 定义泛型方法"></a>1. 定义泛型方法</h2><p>泛型方法的定义格式如下：</p><pre><code class="java">&lt;泛型标记符1, 泛型标记符2……&gt; 返回类型 方法名(泛型标记符1 变量名1, 泛型标记符2 变量名2……) &#123;&#125;</code></pre><h3 id="1-1-泛型标记符出现了两次"><a href="#1-1-泛型标记符出现了两次" class="headerlink" title="1.1 泛型标记符出现了两次"></a>1.1 泛型标记符出现了两次</h3><p>一次在&lt;&gt;中，一次在()中，其中：</p><blockquote><ul><li>&lt;&gt;中指明在接下来的函数参数列表中可以使用的泛型标记符</li><li>()中是函数参数，可以出现的类型有：<ul><li>8种基本数据类型</li><li>&lt;&gt;中的泛型标记符</li><li>定义泛型类（如果这个方法在一个泛型类中）时的泛型标记符</li></ul></li></ul></blockquote><p>比如下面代码：</p><pre><code class="java">class TestClass&lt;T&gt; &#123;    public &lt;U, V&gt; void f(int a, T b, U c) &#123;    &#125;&#125;</code></pre><p>泛型方法 <code>f()</code> 共有3个参数，包括：</p><ul><li><p>1个基本数据类型a，在<strong>定义函数</strong>的时候就指明是int类型的了</p></li><li><p>1个泛型参数类型b，在<strong>实例化对象</strong>的时候才能确定T代表的数据类型（T是定义泛型类时使用的泛型参数）</p></li><li><p>1个泛型参数类型c，在<strong>调用函数</strong>的时候才能确定U代表的数据类型（U是定义泛型方法时使用的泛型参数）</p></li></ul><p>上面泛型方法在定义的时候<strong>提供了两个泛型参数即U和V</strong>，但实际在参数列表中<strong>只使用了一个U</strong>，虽然这种写法很神经，但这种写法在语法上没问题。</p><h3 id="1-2-注意泛型方法和使用泛型类中的类型参数的方法"><a href="#1-2-注意泛型方法和使用泛型类中的类型参数的方法" class="headerlink" title="1.2 注意泛型方法和使用泛型类中的类型参数的方法"></a>1.2 注意泛型方法和使用泛型类中的类型参数的方法</h3><pre><code class="java">class TestClass&lt;T&gt; &#123;    void f_1(T t) &#123;//这只是使用了定义泛型类时的类型参数，不是泛型方法        System.out.println(&quot;这不是泛型方法&quot;);    &#125;    public &lt;U&gt; void f_2(U u) &#123;//这才是泛型方法        System.out.println(&quot;这才是泛型方法&quot;);    &#125;&#125;</code></pre><ul><li>定义泛型方法：函数签名的返回值前面加了<code>&lt;&gt;</code></li><li>使用泛型类中的类型参数：函数签名中仅有参数中使用了定义类时的类型参数</li></ul><h3 id="1-3-泛型方法的几种定义方式"><a href="#1-3-泛型方法的几种定义方式" class="headerlink" title="1.3 泛型方法的几种定义方式"></a>1.3 泛型方法的几种定义方式</h3><pre><code class="java">class TestClass&lt;T&gt; &#123;    public void f_1(T t) &#123;//这只是使用了定义泛型类时的类型参数，不是泛型方法        System.out.println(&quot;这不是泛型方法&quot;);    &#125;        public &lt;U&gt; void f_2(U u) &#123;//这才是泛型方法        System.out.println(&quot;这才是泛型方法&quot;);    &#125;        public static &lt;U&gt; void f_3(U u) &#123;//静态泛型方法        System.out.println(&quot;静态泛型方法&quot;);    &#125;        public &lt;U, V&gt; void f_4(U u, V v) &#123;//同时使用多个类型参数        System.out.println(&quot;使用多个类型参数&quot;);    &#125;        public &lt;U&gt; void f_5(U u, T t) &#123;//使用了定义泛型类时的类型参数        System.out.println(&quot;使用了定义泛型类时的类型参数&quot;);    &#125;&#125;</code></pre><h3 id="1-4-泛型方法重载"><a href="#1-4-泛型方法重载" class="headerlink" title="1.4 泛型方法重载"></a>1.4 泛型方法重载</h3><p>对泛型方法重载时，只可以通过参数数目进行重载，如：</p><pre><code class="java">class TestClass &#123;    public &lt;T&gt; void f_1(T t) &#123;    &#125;    public &lt;U&gt; void f_1(U u) &#123;//类型参数数目相同，编译报错    &#125;    public &lt;T&gt; void f_1(T t1, T t2) &#123;//类型参数数目不同，方法重载    &#125;&#125;</code></pre><p><code>public &lt;T&gt; void f_1(T t)</code> 和 <code>public &lt;U&gt; void f_1(U u)</code> 仅仅是使用的类型参数名字不同（一个是T一个是U），无法区分两个方法。</p><h3 id="1-5-泛型方法和可变长参数"><a href="#1-5-泛型方法和可变长参数" class="headerlink" title="1.5 泛型方法和可变长参数"></a>1.5 泛型方法和可变长参数</h3><pre><code class="java">class TestClass &#123;    public &lt;T&gt; void f_1(T... args) &#123;        for (T t : args) &#123;            System.out.println(t);        &#125;    &#125;&#125;</code></pre><h2 id="2-调用泛型方法"><a href="#2-调用泛型方法" class="headerlink" title="2. 调用泛型方法"></a>2. 调用泛型方法</h2><p>显式调用泛型方法的格式如下：</p><pre><code class="java">对象名(或类名，如果是静态方法).&lt;数据类型1, 数据类型2……&gt;方法名(参数1, 参数2……)</code></pre><p>同时，泛型方法也支持非显式调用。实例化泛型类或者实现泛型接口时需要指定类型参数（否则自动设置为Object），但<strong>在调用泛型方法时，通常不需要指定参数类型</strong>，编译器会根据传入参数的数据类型自动判断出类型参数所代表的具体数据类型，这被称为<strong>类型参数推断</strong>。对于基本类型，编译器还可以根据变量类型进行<strong>自动装箱</strong>（将基本类型自动转换成它们对应的包装类，将包装类自动转换成它们对应的基本类型称为<strong>自动拆箱</strong>）。</p><h3 id="2-1-一个类型参数"><a href="#2-1-一个类型参数" class="headerlink" title="2.1 一个类型参数"></a>2.1 一个类型参数</h3><pre><code class="java">public class Main &#123;    private static &lt;T&gt; void f(T t) &#123;        System.out.println(t);    &#125;    public static void main(String[] args) &#123;        Main.f(1);//自动装箱成 Integer        Main.&lt;Integer&gt;f(1);//与上面等价        Main.f(&#39;a&#39;);//自动装箱成 Character        Main.&lt;Character&gt;f(&#39;a&#39;);        Main.f(&quot;abc&quot;);//字符串是一个String类型的对象，不是基本类型，不进行自动装箱        Main.&lt;String&gt;f(&quot;abc&quot;);    &#125;&#125;</code></pre><h3 id="2-2-多个类型参数"><a href="#2-2-多个类型参数" class="headerlink" title="2.2 多个类型参数"></a>2.2 多个类型参数</h3><ul><li><p>显式调用的时候根据指定的参数类型设置</p></li><li><p>非显式调用的时候会进行类型推断，若参数的类型相同则设置为相同的类型，否则将类型参数设置为<strong>所有传入参数最小的共同父类</strong>，比如：</p><ul><li>1 和 2 取  Integer</li><li>1.2 和 3 取 Number</li><li>1 和 “abc” 取 Object</li></ul><pre><code class="java">public class Main &#123;    private static &lt;T, U&gt; void f(T t, U u) &#123;        System.out.println(t);    &#125;    public static void main(String[] args) &#123;        Main.f(1, 2);//自动装箱为 Integer 和 Integer        Main.&lt;Integer, Integer&gt;f(1, 2);//与上面等价，参数类型相同取相同的        Main.f(1.2, 3);//自动装箱为 Double 和 Integer        Main.&lt;Number, Number&gt;f(1.2, 3);//与上面等价，设置为 Double 和 Integer 的最小共同父类 Number        Main.f(1, &quot;abc&quot;);//1自动装箱为 Integer        Main.&lt;Object, Object&gt;f(1, &quot;abc&quot;);//与上面等价，设置为 Integer 和 String 的最小共同父类 Object    &#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型3——泛型接口</title>
      <link href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-定义泛型接口"><a href="#1-定义泛型接口" class="headerlink" title="1. 定义泛型接口"></a>1. 定义泛型接口</h2><p>类似泛型类的定义，泛型接口的定义格式如下：</p><pre><code class="java">interface 接口名 &lt;泛型标记符1, 泛型标记符2……&gt; &#123;&#125;</code></pre><p>比如，下面这个泛型接口：</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    T t;//编译时报错，接口中的变量会被隐式的指定为 public static final 变量        static void f(T t)&#123;//编译时报错，静态方法不能使用定义泛型接口时使用的泛型标记符            &#125;    public abstract void print(T t);&#125;</code></pre><p>泛型接口中的变量会被隐式的指定为 public static final 变量，因此<strong>泛型接口中的变量不可以使用定义泛型接口时使用的泛型标记符</strong>。同样，<strong>接口中的静态方法（Java8开始，接口里可以使用静态方法）也不能使用定义泛型接口时使用的泛型标记符</strong>。</p><h2 id="2-实现泛型接口"><a href="#2-实现泛型接口" class="headerlink" title="2. 实现泛型接口"></a>2. 实现泛型接口</h2><p>泛型类也可以继承，任何一个泛型类都可以作为父类或子类。不过泛型类在继承时需要注意以下几点：</p><ol><li><p>类是泛型类，</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    public abstract void print(T t);&#125;//类中与接口同名的泛型标记符可以传递给接口//类的泛型标记符包含接口的泛型标记符class TestClass_1&lt;T&gt; implements TestInterface&lt;T&gt; &#123;    @Override    public void print(T t) &#123;        System.out.println(t);    &#125;&#125;class TestClass_2&lt;T, U, V, W&gt; implements TestInterface&lt;T&gt; &#123;    @Override    public void print(T t) &#123;        System.out.println(t);    &#125;&#125;//类的泛型标记符不包含接口中的泛型标记符class TestClass_3&lt;U, V, W&gt; implements TestInterface&lt;String &gt; &#123;//指明接口泛型参数的数据类型    @Override    public void print(String s) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成String    &#125;&#125;class TestClass_4&lt;U, V, W&gt; implements TestInterface&#123;//未指明接口泛型参数的数据类型，则默认接口泛型参数是Object    @Override    public void print(Object o) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成Object    &#125;&#125;</code></pre></li><li><p>类不是泛型类</p><pre><code class="java">interface TestInterface&lt;T&gt; &#123;    public abstract void print(T t);&#125;class TestClass_5 implements TestInterface&lt;String&gt; &#123;//指明接口泛型参数的数据类型    @Override    public void print(String s) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成String    &#125;&#125;class TestClass_6 implements TestInterface &#123;//未指明接口泛型参数的数据类型，则默认接口泛型参数是Object    @Override    public void print(Object o) &#123;//注意，接口中使用泛型参数的函数也要做出相应的改变设置成Object    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型2——泛型类</title>
      <link href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB/"/>
      <url>/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-定义泛型类"><a href="#1-定义泛型类" class="headerlink" title="1. 定义泛型类"></a>1. 定义泛型类</h2><p>Java定义泛型类与定义非泛型类的方法类似，只是需要自类名后面添加<strong>类型参数</strong>。<strong>类型参数用尖括号括住，放在类名后面，泛型类接受多个类型参数，参数间用逗号隔开</strong>。具体的定义格式如下：</p><pre><code class="java">class 类名 &lt;泛型标记符1, 泛型标记符2……&gt; &#123;    private 泛型标记符1 t1;    private 泛型标记符2 t2;        private void setT1(泛型标记符1 t1) &#123;        this.t1 = t1;    &#125;    ……&#125;</code></pre><p>其中，泛型标记符相当于一个<strong>类型占位符</strong>，提示这里需要一个类型参数并暂时使用泛型标记符表示，具体是哪种类型需要等实际使用也就是实例化对象的时候才能确定。</p><p>泛型标记符是可以任意设置的，但为了方便阅读代码，建议遵循以下规范：</p><blockquote><ul><li><p>T：任意的Java类</p></li><li><p>E：集合中的元素</p></li><li><p>K：键值对中的键</p></li><li><p>V：键值对中的值</p></li><li><p>N：数值类型</p></li></ul></blockquote><p>比如，下面这个泛型类：</p><pre><code class="java">class Test&lt;T, SetItAnyWill&gt; &#123;    private T a;//成员变量a的数据类型为 T ，T 代表的具体类型在实例化时指定    private SetItAnyWill b;//成员变量b的数据类型为 SetItAnyWill ，SetItAnyWill 代表的具体类型在实例化时指定    public void setA(T aValue) &#123;        this.a = aValue;    &#125;    public void setB(SetItAnyWill bValue) &#123;        this.b = bValue;    &#125;    public T getA() &#123;        return this.a;    &#125;    public SetItAnyWill getB() &#123;        return this.b;    &#125;&#125;</code></pre><p>这个泛型类包含两个泛型标记符，分别叫做 <code>T</code> 和 <code>SetItAnyWill</code> （之所以取这个名字，只是想再展示一下泛型标记符可以任意设置），至于 <code>T</code> 和 <code>SetItAnyWill</code> 具体代表的是什么类型，只有实例化这个类时（见下面“使用泛型类”）才会确定下来。</p><p>注意，<strong>泛型类中静态变量和静态方法不可以使用定义泛型类时使用的泛型标记符</strong>（静态变量和静态方法在类加载时已经初始化，而此时泛型类的类型参数还未指定，因此不能使用泛型类的泛型标记符），但静态方法可以在定义时使用新的泛型标记符（此时，静态方法成为泛型方法）。如：</p><pre><code class="java">class Test&lt;T, SetItAnyWill&gt; &#123;    static T staticA;//编译时报错，静态变量不允许使用定义泛型类时用的泛型标记符    static void setStaticA(T staticAValue) &#123;//编译时报错，静态方法不允许使用定义泛型类时用的泛型标记符    &#125;    static &lt;N&gt; void print(N number)&#123;//静态方法可以在定义时使用新的泛型标记符，泛型标记符在定义泛型类时未使用过        System.out.println(number);    &#125;&#125;</code></pre><p><em>泛型方法如何定义和使用后面会有具体的介绍。</em></p><h2 id="2-使用泛型类"><a href="#2-使用泛型类" class="headerlink" title="2. 使用泛型类"></a>2. 使用泛型类</h2><p>有两种实例化一个泛型类的对象的格式，一种是Java5开始使用的语法，一种是从Java7开始使用的简写语法，如下：</p><pre><code class="java">类名&lt;数据类型1, 数据类型2……&gt; 对象名 = new 类名&lt;&gt;();//Java7开始使用的简写语法类名&lt;数据类型1, 数据类型2……&gt; 对象名 = new 类名&lt;数据类型1, 数据类型2……&gt;();//Java5使用的语法</code></pre><p>比如：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        Test&lt;String, Integer&gt; test = new Test&lt;&gt;(); //T 被替换为 Sting，SetItAnyWill 被替换为 Integer        test.setA(&quot;this is string&quot;);        test.setB(10);        //test.setA(20);//编译报错，对于 test 来说 setA()方法需要传入一个字符串        //test.setB(&quot;this is string&quot;);//编译报错，对于 test 来说 setB()方法需要传入一个整形变量                Test&lt;Integer, Character&gt; another = new Test&lt;&gt;(); //T 被替换为 Integer，SetItAnyWill 被替换为 Character        another.setA(30);        another.setB(&#39;a&#39;);        //another.setA(true);//编译报错，对于 another 来说 setA()方法需要传入一个整形变量        //another.setB(&quot;cde&quot;);//编译报错，对于 another 来说 setA()方法需要传入一个字符    &#125;&#125;</code></pre><p>为了便于理解，当使用<code>Test&lt;String, Integer&gt; test = new Test&lt;&gt;();</code>实例化一个泛型类后，我们可以认为编译器会将上面定义的泛型类根据&lt;&gt;中传入的数据类型进行泛型标记符替换（<strong>仅仅是便于理解，实际不是这样的</strong>），替换后的代码如下：</p><pre><code class="java">//泛型标记符 T 被替换为 String//泛型标记符 SetItAnyWill 被替换为 Integerclass Test&#123;    private String a;    private Integer b;    public void setA(String aValue) &#123;        this.a = aValue;    &#125;    public void setB(int bValue) &#123;        this.b = bValue;    &#125;    public String getA() &#123;        return this.a;    &#125;    public Integer getB() &#123;        return this.b;    &#125;&#125;</code></pre><p>在使用泛型类时需要注意以下几点：</p><blockquote><ul><li><p>传入的类型参数需要和定义泛型类时的数目保持一致</p></li><li><p>可以不传入类型参数，此时默认传入的是Object类，比如：</p></li></ul><p><code>Test test1 = new Test();//不传入类型参数</code></p><p>这相当于：</p><p><code>Test&lt;Object, Object&gt; test1 = new Test&lt;&gt;();</code></p><ul><li><p>类型参数只能是引用类型，不能是基本类型</p></li><li><p>Java有8种基本类型，这8种类型在使用泛型类时不能作为类型参数传入，只能使用对应的封装类型</p></li><li><p>基本类型及其对应的封装类：</p><table><thead><tr><th>基本类型</th><th>封装类</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>Integer</td><td>32</td><td>-2^31 ~ 2^31-1</td><td>0</td><td>整型</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>-2^15 ~ 2^15-1</td><td>0</td><td>短整型</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>-2^63 ~ 2^63-1</td><td>0</td><td>长整型</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>-2^128 ~ 2^128</td><td>0.0f或0.0F</td><td>单精度浮点型</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>-2^1024 ~ 2^1024</td><td>0</td><td>双精度浮点型，默认的小数类型</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>‘\u0000’ ~ ‘\uFFFF’</td><td>‘\u0000’</td><td>字符型，Unicode编码</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td>true 或 false</td><td>false</td><td>布尔型</td></tr><tr><td>byte</td><td>Byte</td><td>8</td><td>-2^7 ~ 2^7-1</td><td>0</td><td>字符型，数据在内存中的最原始状态</td></tr></tbody></table></li></ul></blockquote><h2 id="3-泛型类的继承"><a href="#3-泛型类的继承" class="headerlink" title="3. 泛型类的继承"></a>3. 泛型类的继承</h2><p>泛型类也可以继承，任何一个泛型类都可以作为父类或子类。不过泛型类在继承时需要注意以下几点：</p><ol><li><p>子类是泛型类，</p><pre><code class="java">class Father&lt;T&gt; &#123;&#125;//子类中与父类同名的泛型标记符可以传递给父类//子类的泛型标记符包含父类的泛型标记符class Child_1&lt;T&gt; extends Father&lt;T&gt; &#123;&#125;class Child_2&lt;T, U, V, W&gt; extends Father&lt;T&gt; &#123;&#125;//子类的泛型标记符不包含父类的泛型标记符class Child_3&lt;U, V, W&gt; extends Father&lt;String&gt;&#123;//指明父类泛型参数的数据类型&#125;class Child_4&lt;U, V, W&gt;extends Father&#123;//未指明父类泛型参数的数据类型，则默认父类泛型参数是Object&#125;</code></pre></li><li><p>子类不是泛型类</p><pre><code class="java">class Father&lt;T&gt; &#123;&#125;class Child_5 extends Father&lt;String&gt;&#123;//指明父类泛型参数的数据类型&#125;class Child_6 extends Father&#123;//未指明父类泛型参数的数据类型，则默认父类泛型参数是Object&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型1——概述</title>
      <link href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：以下内容基于Java 8，所有代码都已在Java 8环境下测试通过</p></blockquote><p>目录：</p><ul><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0">Java泛型1——概述</a></li><li><a href="/2023/07/28/Java%E6%B3%9B%E5%9E%8B2%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E7%B1%BB">Java泛型2——泛型类</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B3%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">Java泛型3——泛型接口</a></li><li><a href="/2023/07/29/Java%E6%B3%9B%E5%9E%8B4%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">Java泛型4——泛型方法</a></li><li><a href="/2023/08/01/Java%E6%B3%9B%E5%9E%8B5%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">Java泛型5——泛型通配符</a></li><li><a href="/2023/08/02/Java%E6%B3%9B%E5%9E%8B6%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">Java泛型6——类型擦除</a></li></ul><h2 id="1-泛型是什么"><a href="#1-泛型是什么" class="headerlink" title="1. 泛型是什么"></a>1. 泛型是什么</h2><p>泛型，即<strong>类型参数</strong>，类似于函数中的参数，泛型可以将<strong>类型参数化</strong>。这句话过于抽象，为了便于解释，下面根据个人理解将泛型与函数中的参数做个对比。</p><p>从简单的人手，首先说一下函数参数经历的两个阶段：</p><ul><li><p>函数定义</p><p>在定义函数时，只知道参数的类型而不知道具体的值（此时的参数叫做形参）。此时，为了定义函数在参数上的操作，我们需要给参数取个名字，比如下面这个函数：</p><pre><code class="java">private void testF(int a, int b) &#123;    System.out.println(a);    System.out.println(b);&#125;</code></pre><p>在这个函数定义中，只知道有两个 <code>int</code> 类型的参数且名字分别叫a、b，但具体的值此时尚不知道。</p></li><li><p>函数调用</p><p>在调用函数时，我们需要按照函数的要求传入两个<code>int</code>类型的变量：</p><pre><code class="java">//调用函数testF(1. 2);</code></pre></li></ul><p>从上面可以看出来，对于函数参数而言：<strong>函数在定义时知道参数的类型和名字，但不知道具体的值，在函数调用时才知道具体的值是多少</strong>。而泛型更进一步，以泛型方法为例，<strong>在定义一个泛型方法时，仅仅知道参数的名字，而参数的类型和具体的值只有在调用函数的时候才能确定！</strong></p><p>另外，与函数参数不同的是，类、接口、函数中都可以加入泛型机制，即为类、接口、函数指定类型参数，分别被叫做<strong>泛型类、泛型接口、泛型函数</strong>。</p><h2 id="2-泛型的作用"><a href="#2-泛型的作用" class="headerlink" title="2. 泛型的作用"></a>2. 泛型的作用</h2><p>根据<a href="https://www.ituring.com.cn/book/2935">《On Java 8》</a>的描述：“<strong>泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足</strong>”。</p><p>Talk is cheap,let me show you the code，假设我们现在有个很简单的需求：需要<strong>用一个集合存放String类型的变量，并将这个集合中的内容打印输出</strong>。使用泛型可以这样写:</p><h3 id="2-1-通过泛型实现"><a href="#2-1-通过泛型实现" class="headerlink" title="2.1 通过泛型实现"></a>2.1 通过泛型实现</h3><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;String&gt; stringList = new LinkedList&lt;&gt;(); //&lt;String&gt; 是一个泛型                stringList.add(&quot;abc&quot;);        stringList.add(&quot;def&quot;);        //stringList.add(1); //当添加一个非 String 类型的变量时，编译器会报错                for (int i = 0; i &lt; stringList.size(); i++) &#123;            System.out.println(stringList.get(i));        &#125;    &#125;&#125;</code></pre><p>在上面的代码中：</p><ol><li><code>&lt;String&gt;</code>是一个泛型，它限制了<code>stringList</code>中只能存放<code>String</code>类型的变量（约定集合要存储什么类型的对象）</li><li><code>stringList.add(1);</code>，由于泛型的存在，当<code>stringList</code>试图添加一个非String类型的变量时，编译器会报错（通过编译器确保规约（也就是只能存放String类型变量）得以满足）</li></ol><p>第一点实际展示了如何使用泛型，这再后面还会再详细介绍，先具体说一下第二点：如何理解<strong>通过编译器确保规约得以满足</strong>？在Java中，<strong>Object类是所有类的超类</strong>，通过向下转型，下面这段代码可以实现和上面类似的功能：</p><h3 id="2-2-通过Object和转型实现"><a href="#2-2-通过Object和转型实现" class="headerlink" title="2.2 通过Object和转型实现"></a>2.2 通过Object和转型实现</h3><pre><code class="java">import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList stringList = new LinkedList(); //未使用泛型机制，此时可以放入任何类型的变量        stringList.add(&quot;abc&quot;);        stringList.add(&quot;def&quot;);        stringList.add(1); //可以添加非 String 类型的变量，编译器不会报错        for (int i = 0; i &lt; stringList.size(); i++) &#123;            System.out.println((String) stringList.get(i));        &#125;    &#125;&#125;</code></pre><p>上面这段代码在定义<code>stringList</code>时未使用泛型机制，因此可以添加任意类型的变量，即使添加的变量类型不同<strong>编译器也不会报错</strong>。但！！！在执行代码时会出现错误：</p><p><img src="/2023/07/28/Java%E6%B3%9B%E5%9E%8B1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/1.jpg" alt="1"></p><p>这个错误是由于我们错误的将<code>Integer</code> 类型强制转换为<code>String</code>类型而引起的。</p><p>当然，这个报错我们可以通过<strong>反射机制</strong>避免，但这种错误处理方式太过繁琐，而且会大大降低代码的复用性（若通过泛型，可以很轻松的将功能改为存放并输出<code>Integer</code>类型对象，而使用泛型则需要添加新的判断逻辑）。</p><p>另外，我们不能寄希望于其他人（甚至自己）会一直按照规定调用代码。因此，最好的方式就是<strong>尽可能的在程序编译阶段就将问题暴露出来</strong>，而不是等用户真正使用产品的时候再去修改本不该出现的bug。而泛型就有这个能力：<strong>通过编译器确保规约得以满足</strong>！</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>在这篇博客里，简单概述了一下泛型，接下来将分几篇博客分别介绍泛型类、泛型接口、泛型方法等，随着使用的逐渐深入，对泛型将会有更多的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透</title>
      <link href="/2023/07/26/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2023/07/26/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>放假回家需要远程实验室的电脑，虽然可以通过Windows自带的远程功能加VPN访问，但有时电脑会重启，开机后电脑IP地址也就变了。为了确保万无一失，设置了内网穿透，实现通过公网IP访问内网机器的功能。</p><h2 id="1-frp介绍"><a href="#1-frp介绍" class="headerlink" title="1. frp介绍"></a>1. frp介绍</h2><p>frp是一个开源的内网穿透工具，支持TCP、UDP、HTTP、HTTPS等协议，可以将内网的机器安全、便捷的通过具有公网IP的机器暴露到公网中。<strong>（太过抽象，可以跳过这一部分，直接进入准备工作，配置好之后再回来看就会明白了）</strong></p><ul><li><p>frp项目地址：<a href="https://github.com/fatedier/frp">frp</a></p></li><li><p>frp工作原理</p><p>frp需要一台具有公网IP地址的机器作为服务端，内网中的机器作为客户端。frp包括两部分，frps以及frpc，服务端运行frps，客户端运行frpc，其工作原理如下：</p><ul><li>服务端运行frps，对设置的<strong>主端口</strong>进行监听，等待客户端的连接</li><li>客户端运行frpc，连接到服务端，同时告诉服务端<strong>要监听的端口</strong>和<strong>转发类型</strong></li><li>服务端开启新的进程监听客户端指定的端口</li><li>公网用户连接到服务端的端口（该端口是第二步中客户端指定的端口），服务端将数据转发到客户端</li></ul></li></ul><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><p>这里我的服务端是一台Linux服务器，客户端是一台Windows电脑。</p><ol><li><p>下载frp：<a href="https://github.com/fatedier/frp/releases">frp下载地址</a></p><p>需要根据对应的操作系统和CPU架构，分别在服务端和客户端下载对应的frp。</p></li><li><p>解压frp</p><p>下载解压之后，服务器端保留<strong>frps、frps.ini、LICENSE</strong>这三个文件，电脑保留<strong>frpc、frpc.ini、LICENSE</strong>这三个文件即可。</p></li><li><p>Linux以及Windows需设置防火墙开放对应的端口，根据下面的配置，Linux需开启7000（该端口用于服务端与客户端之间建立联系）以及9000端口（该端口用于公网用户连接内网Windows），Windows需开启3389端口（该端口用于远程桌面）。</p></li></ol><h2 id="3-服务器端配置"><a href="#3-服务器端配置" class="headerlink" title="3. 服务器端配置"></a>3. 服务器端配置</h2><h3 id="3-1-frps配置"><a href="#3-1-frps配置" class="headerlink" title="3.1 frps配置"></a>3.1 frps配置</h3><p>打开 <code>frps.ini</code> 文件，输入以下内容：</p><pre><code class="shell">[common]bind_port = 7000 # 主端口，可设置为其他端口，客户端将通过该端口与服务端建立通信token = thisispassword # 用于身份验证</code></pre><h3 id="3-2-启动frps"><a href="#3-2-启动frps" class="headerlink" title="3.2 启动frps"></a>3.2 启动frps</h3><p>在解压后的文件夹内输入以下内容：</p><pre><code class="shell">./frps -c ./frps.ini</code></pre><h3 id="3-3-设置开机自启"><a href="#3-3-设置开机自启" class="headerlink" title="3.3 设置开机自启"></a>3.3 设置开机自启</h3><p>经过以上设置，frps已经在服务器上启动并监听7000端口了，但服务器重启后需要手动启动frps，因此这里再设置一下frps开机自启。</p><ol><li><p>在**&#x2F;lib&#x2F;systemd&#x2F;system** 下面新建一个文件<strong>frps.service</strong>:</p><pre><code class="shell">vim /lib/systemd/system/frps.service</code></pre></li><li><p>写入以下内容</p><pre><code class="shell">[Unit]Description=frps[Service]Type=simpleExecStart=frps所在文件夹/frps -c frps所在文件夹/frps.ini[Install]WantedBy=multi-user.target</code></pre></li><li><p>启动</p><pre><code class="shell">systemctl start frps</code></pre></li><li><p>设置开机自启</p><pre><code class="shell">systemctl enable frps</code></pre></li></ol><h2 id="4-电脑端"><a href="#4-电脑端" class="headerlink" title="4. 电脑端"></a>4. 电脑端</h2><h3 id="4-1-frpc配置"><a href="#4-1-frpc配置" class="headerlink" title="4.1 frpc配置"></a>4.1 frpc配置</h3><p>打开frpc.ini文件，输入以下内容：</p><pre><code class="shell">[common]server_addr = 服务器的公网IP地址server_port = 7000 # frps.ini里面设置的主端口token = thisispassword # 与frps.ini里面设置的保持一致[RDP]type = tcplocal_ip = 127.0.0.1local_port = 3389 # 本地需要映射到服务器上的端口remote_port = 9000 # 映射到服务器上的端口</code></pre><h3 id="4-2-启动frpc"><a href="#4-2-启动frpc" class="headerlink" title="4.2 启动frpc"></a>4.2 启动frpc</h3><p>在 <code>frpc.ini</code> 所在的文件夹进入命令行窗口，输入：</p><pre><code class="shell">./frpc -c ./frpc.ini</code></pre><p>启动成功后：</p><blockquote><ol><li>服务器端的7000端口将监听到有个frpc客户端想要与服务器建立连接</li><li>服务器端根据客户端的设置开始监听9000端口</li><li>若此时有台电脑<strong>访问服务器的9000端口</strong>，则根据frp的映射，将实际访问客户端的3389端口也就<strong>是访问Windows电脑的远程</strong></li></ol></blockquote><h3 id="4-3-设置开机自启桌面"><a href="#4-3-设置开机自启桌面" class="headerlink" title="4.3 设置开机自启桌面"></a>4.3 设置开机自启桌面</h3><p>同样，为了避免手动启动的麻烦，frpc也需要设置开机自启。借助winsw设置Windows下frpc的开机自启：</p><ol><li><p>根据需要<a href="https://github.com/winsw/winsw/releases">下载winsw-*.exe</a></p></li><li><p>将下载的 <code>winsw-*.exe</code> 放到 <code>frpc</code> 所在的文件夹</p></li><li><p>新建一个名为 <code>winsw.xml</code> 的文件，写入以下内容：</p><pre><code class="xml">&lt;service&gt;    &lt;id&gt;frp&lt;/id&gt;    &lt;name&gt;frp&lt;/name&gt;    &lt;description&gt;frp&lt;/description&gt;    &lt;executable&gt;frpc&lt;/executable&gt;    &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt;    &lt;logmode&gt;reset&lt;/logmode&gt;&lt;/service&gt;</code></pre></li><li><p>管理员权限打开命令行窗口，进入到 <code>frpc</code> 所在的文件夹，输入以下内容</p><pre><code class="shell">winsw install</code></pre></li></ol><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>frp还提供了后台管理等功能，具体可参考<a href="https://gofrp.org/docs/">frp文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 百宝箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百宝箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器3——Map</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/</url>
      
        <content type="html"><![CDATA[<p>以下内容参考《<a href="https://www.programmercarl.com/other/kstar_baguwen.html">代码随想录知识星球精华（最强⼋股⽂）第三版</a>》整理。</p><h2 id="Map继承关系图"><a href="#Map继承关系图" class="headerlink" title="Map继承关系图"></a>Map继承关系图</h2><p>（该图基于JDK8，仅包含部分类。为了方便查看，部分关系未画出）</p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/Map.jpg" alt="Map继承关系"></p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A83%E2%80%94%E2%80%94Map/Map%E6%8E%A5%E5%8F%A3.jpg" alt="Map接口"></p><ul><li>Map是⼀组键值对，键不可重复，值可重复</li><li>常⽤的实现类有：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器2——Collection</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/</url>
      
        <content type="html"><![CDATA[<p>以下内容参考《<a href="https://www.programmercarl.com/other/kstar_baguwen.html">代码随想录知识星球精华（最强⼋股⽂）第三版</a>》整理。</p><h2 id="Collection继承关系图"><a href="#Collection继承关系图" class="headerlink" title="Collection继承关系图"></a>Collection继承关系图</h2><p>（该图基于JDK8，仅包含部分类。为了方便查看，部分关系未画出）</p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Collection.jpg" alt="Collection继承关系"></p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Collection%E6%8E%A5%E5%8F%A3.jpg" alt="Collection接口"></p><ul><li>Collection下的所有实现类都是继承⾃AbstractCollection，该类将基础⽅法 size 和 iterator 抽象化，但是实现了其他的⽅法</li><li>AbstractCollection下派⽣出AbstractList、AbstractSet、AbstractQueue、ArrayQueue</li><li>List下的全部继承⾃AbstractList，List是一个存储有序的集合，允许重复，每个元素都有一个索引</li><li>Set下的继承⾃AbstractSet，Set是一个无需存储的集合，不允许重复</li></ul><p><strong>Java中经常使⽤的语法糖”for each”循环可以与任何实现了Iterable接⼝的对象⼀起⼯作</strong>。<br>Collection通过调用iterator()⽅法返回⼀个Iterator对象，这就是常⽤的迭代器，其中包含hasNext()、next()、remove()、forEachRemaining(Consumer)4个⽅法。</p><p>Iterator()的功能简单，只能单向移动：</p><ol><li>调⽤iterator()⽅法返回⼀个Iterator对象</li><li>第⼀次调⽤Iterator的next()⽅法，返回序列的第⼀个元素。此后每调⽤⼀个next(),会返回序列的下⼀个元素。调⽤next()⽅法前最好先调⽤hasNext()⽅法，判断序列后⾯是否还有元素</li><li>remove()删除上次next()返回的对象，remove()只能在next()之后使⽤，并且⼀个remove()匹配⼀个next()，不能重复调⽤</li><li>使⽤hasNext()判断序列中是否还有元素</li></ol><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/List%E6%8E%A5%E5%8F%A3.jpg" alt="List接口"></p><ul><li>List接⼝常⽤的实现类有<strong>ArrayList、LinkedList</strong></li><li>相比Collection，List多出sort()、get()、listIterator()等⽅法，listIterator返回⼀个链表迭代器</li></ul><p>List有着特殊的迭代器接口ListIterator，该接口继承自Iterator接⼝。ListIterator是⼀个功能更加强⼤的迭代器，Iterator是单向的，但ListIterator是双向的，ListIterator增加了previous()和hasPrevious()⽅法⽤来反向遍历。<strong>注意只能List使⽤ListIterator。</strong></p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/ListIterator.jpg" alt="ListIterator"></p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Set%E6%8E%A5%E5%8F%A3.jpg" alt="Set接口"></p><ul><li>Set常⽤的实现类有<strong>HashSet、TreeSet、LinkedHashSet</strong></li></ul><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Queue%E6%8E%A5%E5%8F%A3.jpg" alt="Queur接口"></p><p><img src="/2023/07/25/Java%E5%AE%B9%E5%99%A82%E2%80%94%E2%80%94Collection/Deque.jpg" alt="Deque"></p><ul><li>Deque接⼝继承⾃Queue,在Deque的基础上更加细化，可以选择从头部或者尾部操作。如果Deque中使⽤Queue的⽅法，⼀定要清楚实现类是从头部还是尾部操作的</li><li><strong>很多实现类既实现类List接⼝，⼜实现类Queue接⼝</strong>，如<strong>LinkedList即实现了List接口又实现了Deque接口（因此LinkedList即可以使用add又可以使用addLast）</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器1——概述</title>
      <link href="/2023/07/25/Java%E5%AE%B9%E5%99%A81%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/25/Java%E5%AE%B9%E5%99%A81%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Java容器主要分为两大类：</p><ul><li>Collection：一个独立元素的序列，一次存一个元素，是单列集合。Collection又主要包括以下三种：<ul><li>List：存储的元素有序、可重复，是个常用的容器</li><li>Set：存储的元素无序、不可重复，用于数据需要唯一存在的场景</li><li>Queue：存储的元素有序、可重复，可指定存取数据的先后顺序</li></ul></li><li>Map：一组成对的“键值对”对象，一次存一对元素，是双列集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA Diagrams的使用</title>
      <link href="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近打算整理一下Java的容器类，需要画出容器类的UML类图。找了一下画UML的软件，感觉都不太满意，正好发现IDEA自带的类图分析插件Diagrams可以画类图，而且使用体验还不错。（<strong>IDEA社区版不支持该功能</strong>）</p><h2 id="1-设置Diagrams"><a href="#1-设置Diagrams" class="headerlink" title="1. 设置Diagrams"></a>1. 设置Diagrams</h2><ol><li><p>打开设置界面：<code>File-&gt;Settings</code></p></li><li><p>确保启用Diagrams：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/1.jpg" alt="1"></p></li><li><p>设置Diagrams：<code>Tools-&gt;Diagrams</code>，在这里可以根据需要对Diagrams做具体的设置，因为我只想看一下类之间的继承关系，所以只对继承做了设置。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/2.jpg" alt="3"></p></li></ol><h2 id="2-使用Diagrams"><a href="#2-使用Diagrams" class="headerlink" title="2. 使用Diagrams"></a>2. 使用Diagrams</h2><h3 id="2-1-打开Diagrams"><a href="#2-1-打开Diagrams" class="headerlink" title="2.1 打开Diagrams"></a>2.1 打开Diagrams</h3><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/3.jpg" alt="3">   </p><p>有两种方式可以打开Diagrams，一种是在代码区直接右键选择Diagrams，另一种是在文件的目录树中进入。这里我选择第二种方式，以 <code>LinkedList</code> 为例，在 <code>LinkedList</code> 的文件上右键选择Diagrams，此时有两种选择：</p><ul><li>Show Diagram…：将在代码区新建一个窗口</li><li>Show Diagram Popup…：在当前桌面直接弹出一个缩略图</li></ul><p>这里我选择方法一新建一个窗口，下图中：</p><ul><li><font color='green'>绿色的‘I’是接口</font>，<font color='blue'>蓝色的‘C’是类</font></li><li><font color='green'>绿色虚线是类与接口之间的实现关系</font></li><li><font color='green'>绿色实线是接口之间的继承关系</font></li><li><font color='blue'>蓝色实线是类之间的继承关系</font></li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/4.gif" alt="4"></p><h3 id="2-2-增删类"><a href="#2-2-增删类" class="headerlink" title="2.2 增删类"></a>2.2 增删类</h3><ul><li>添加类：<code>右键-&gt;Content-&gt;Add Class to Diagram</code>（或者在界面中直接按空格）</li><li>删除类：<code>选中类-&gt;右键-&gt;Delete</code>（或者选中类然后按下键盘的Del键）</li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/add_del.gif" alt="add_del"></p><h3 id="2-3-缩放、拖动界面"><a href="#2-3-缩放、拖动界面" class="headerlink" title="2.3 缩放、拖动界面"></a>2.3 缩放、拖动界面</h3><p>按住 <code>Ctrl</code> 键然后滚动<code>鼠标滚轮</code>可以实现缩放当前界面，按住<code>鼠标右键</code>然后拖动鼠标可以移动当前界面，按住 <code>Alt键</code> 出现放大镜。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/5.gif" alt="5"></p><h3 id="2-4-Diagrams工具栏介绍"><a href="#2-4-Diagrams工具栏介绍" class="headerlink" title="2.4 Diagrams工具栏介绍"></a>2.4 Diagrams工具栏介绍</h3><p>这里我将工具栏大致分为以下4部分，下面分别介绍：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/6.jpg" alt="6"></p><ol><li><p>第一部分：</p><p>从左到右点击将依次显示：字段、构造函数、成员函数、属性（具有get和set方法）、内部类。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/7.gif" alt="7"></p></li><li><p>第二部分：</p><p>从左到右依次是：显示依赖关系、更改排序、更改可见级别（如只显示public等）、改变显示范围（如项目文件、非项目文件等）、在节点元素之间创建扩展或实现链接。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/8.gif" alt="8"></p></li><li><p>第三部分：</p><p>从左到右依次是：放大、缩小、恢复实际大小、自动适应当前窗口大小。</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/9.gif" alt="9"></p></li><li><p>第四部分：</p><p>使用右键快捷菜单“布局”选项中选择的当前布局、缩放到窗口的边缘（类似自动布线？）、复制当前界面到剪切板、单击后鼠标选定的区域将被复制到剪切板、导出Diagrams、刷新当前界面、打开Diagrams设置页面、在浏览器中打开帮助页面。</p></li></ol><h3 id="2-5-右键快捷菜单介绍"><a href="#2-5-右键快捷菜单介绍" class="headerlink" title="2.5 右键快捷菜单介绍"></a>2.5 右键快捷菜单介绍</h3><p>选中一个元素然后单击右键将出现以下快捷菜单：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/10.jpg" alt="10"></p><p>不选择任何元素直接在界面单击右键将出现以下快捷菜单：</p><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/11.jpg" alt="11"></p><p>部分功能已经在上面介绍过了，这里仅介绍部分常用的功能，其他功能可参考<a href="https://www.jetbrains.com/help/idea/2023.1/class-diagram-toolbar-and-context-menu.html#menu">帮助文档</a>：</p><ul><li>Selected Element Actions -&gt; Jump to Source：打开该类的源码</li><li>Show Implementations：显示该类的实现和继承</li><li>Show Parents：显示该类实现或继承谁</li></ul><p><img src="/2023/07/24/IntelliJ-IDEA-Diagrams%E7%9A%84%E4%BD%BF%E7%94%A8/12.gif" alt="12"></p><h2 id="3-其它插件"><a href="#3-其它插件" class="headerlink" title="3. 其它插件"></a>3. 其它插件</h2><p>在IntelliJ IDEA的<code>Settings-&gt;Plugins</code>中还可以安装其他的UML类图插件，比如可以安装diagrams，支持直接在IntelliJ IDEA画流程图。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> IDEA技巧 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git同时配置Gitee和GitHub</title>
      <link href="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/"/>
      <url>/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/</url>
      
        <content type="html"><![CDATA[<p>注意，以下基本都在 <code>~/.ssh</code> 目录下以及在这个目录下打开的Git Bash窗口中操作，因此打开 <code>~/.ssh</code> 目录及Git Bash窗口后，暂时不要关闭！</p><h2 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a>配置Git用户名和邮箱</h2><p>首先，为Git设置用户名和邮箱。（若已设置过，则无需设置）</p><pre><code class="shell">git config --global user.name 用户名git config --global user.email 邮箱</code></pre><h2 id="生成SSH-keys"><a href="#生成SSH-keys" class="headerlink" title="生成SSH keys"></a>生成SSH keys</h2><p>许多Git托管网站（如Gitee和GitHub）都使用SSH协议进行认证，因此为了向Gitee和GitHub提供SSH公钥，必须事先为其生成一份SSH密钥对。这个过程在所有操作系统上都是相似的：</p><ol><li><p>进入存放密钥对的文件夹，SSH密钥对存放在 <code>~/.ssh</code> 目录下。在Windows系统下，安装键盘的 <code>Windows</code> 键和 <code>R</code> 键输入 <code>.ssh</code> 回车即可打开</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/1.jpg" alt="1"></p></li><li><p>生成SSH keys</p><p>在<code>~/.ssh</code> 目录下进入Git Bash，输入下列命令然后一直回车即可：</p><pre><code class="shell">ssh-keygen -t rsa -f id_rsa.gitee -C &quot;gitee&quot;ssh-keygen -t rsa -f id_rsa.github -C &quot;github&quot;</code></pre><p>参数含义：</p><ul><li>-t：指定密钥类型，默认是 rsa ，可以省略</li><li>rsa：指使用RSA算法</li><li>-f：指定存储密钥的文件名</li><li>-C：设置注释文字</li></ul><p>若生成成功，则出现</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/2.jpg" alt="2"></p><p>同时，在刚才的 <code>.ssh</code> 文件夹下，将会生成4个新文件：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/3.jpg" alt="3"></p><p>其中：</p><ul><li>id_rsa.xx：私钥</li><li>id_rsa_xx.xx.pub：私钥对应的公钥</li></ul></li></ol><h2 id="添加私钥到ssh-agent中"><a href="#添加私钥到ssh-agent中" class="headerlink" title="添加私钥到ssh-agent中"></a>添加私钥到ssh-agent中</h2><p>Git默认读取的文件文件名为id_rsa，因此我们需要将生成的密钥添加到ssh-agent中。在刚才打开的Git Bash窗口中输入：</p><pre><code class="shell">ssh-agent bashssh-add ~/.ssh/id_rsa.giteessh-add ~/.ssh/id_rsa.github</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在 <code>~/.ssh</code> 目录下打开 <code>config</code> 文件，若没有则新建一个名为 <code>config</code> 的文件（<strong>注意，这个文件不带扩展名，全面就叫做config</strong>），然后添加以下内容：</p><blockquote><p>#Gitee<br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>User git<br>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa.gitee</p><p>#GitHub<br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>User git<br>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa.github</p></blockquote><h2 id="添加公钥到托管网站"><a href="#添加公钥到托管网站" class="headerlink" title="添加公钥到托管网站"></a>添加公钥到托管网站</h2><ol><li><p>Gitee添加公钥</p><p>登录Gitee，进入 <code>设置</code> ，点击 <code>SSH公钥</code> ，输入“标题”以及“公钥”。Gitee对应的公钥存放在 <code>id_rsa.gitee.pub</code> 文件中，打开全部复制即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/4.jpg" alt="4"></p></li><li><p>GitHub添加公钥</p><p>登录GitHub，进入 <code>Settings</code> ，依次点击 <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code> ，输入“Title”以及“Key”。GitHub对应的公钥存放在 <code>id_rsa.github.pub</code> 文件中，打开全部复制即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/5.jpg" alt="5"></p></li></ol><h2 id="测试是否添加成功"><a href="#测试是否添加成功" class="headerlink" title="测试是否添加成功"></a>测试是否添加成功</h2><p>依次在Git Bash中输入：</p><pre><code class="shell">ssh -T git@gitee.com # 测试Giteessh -T git@github.com # 测试GitHub</code></pre><p>第一次连接会让输入 <code>yes/no</code> ，输入 <code>yes</code> 即可：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/6.jpg" alt="6"></p><p>出现下面即代表添加成功：</p><p><img src="/2023/07/22/Git%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEGitee%E5%92%8CGitHub/7.jpg" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Git技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对使用Git、GitHub时邮箱和用户名的理解</title>
      <link href="/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在使用Git以及GitHub时会多次用到“邮箱”和“用户名”，这里记录一下它们的区别。</p><h2 id="登录GitHub时"><a href="#登录GitHub时" class="headerlink" title="登录GitHub时"></a>登录GitHub时</h2><p><img src="/2023/07/13/%E5%AF%B9%E4%BD%BF%E7%94%A8Git%E3%80%81GitHub%E6%97%B6%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3/1.jpg" alt="1"></p><p>这里的用户名或邮箱是<strong>用于登录GitHub</strong>这个网站的。</p><h2 id="配置Git时"><a href="#配置Git时" class="headerlink" title="配置Git时"></a>配置Git时</h2><pre><code class="shell">git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;</code></pre><p>这两条命令是配置 Git 的全局用户名和邮箱，在进行版本控制时用于记录用户身份信息。Git在commit信息中会显示提交人及其邮箱地址，方便追踪提交记录。因此这里的邮箱和用户名是<strong>为了回溯是谁提交的代码</strong>，并不需要一定填写GitHub的用户名和邮箱，甚至是可以随便填写的用户名和邮箱（当然，极其不建议这样做）。</p><p>在使用GitHub时，可能会发现一个bug：虽然提交了commit，但是主页却不显示contributions。这个bug很可能就是在Git配置的邮箱地址与GitHub中的邮箱地址不符合造成的。</p><ul><li>如果本地设定的user.email值与GitHub上的账户的邮件地址相同，GitHub会认定推送代码的操作是账户拥有者自己做的，跟直接登录到GitHub，从网站上修改，是相同的。此时，修改人是一样，就是账户拥有者。</li><li>如果本地设定的user.email值与GitHub不同，也能把代码推送到GitHub（只要密码或者ssh正确），GitHub会记录这次的修改是另一个人做的。</li></ul><h2 id="设置SSH-Key时"><a href="#设置SSH-Key时" class="headerlink" title="设置SSH Key时"></a>设置SSH Key时</h2><p>GitHub通过HTTPS协议（密码）或者SSH验证身份。其中：</p><ul><li>HTTPS协议只认账号。如果使用HTTPS操作远程仓库，则需要使用账号密码来做权限的认证。</li><li>SSH协议只认机器。当使用SSH操作远程仓库的话，需要使用公钥和私钥对来做权限的认证。</li></ul><p>为了方便操作，一般都是使用SSH协议，当使用SSH协议时，需要在本地电脑上生成公钥和私钥对，然后在GitHub上配置公钥。公钥和私钥对使用如下指令生成：</p><pre><code class="shell">ssh-keygen -t rsa -f id_rsa.github -C &quot;XXX&quot;</code></pre><p>其中：</p><ul><li>-t：指定密钥的类型，密钥的类型有RSA和DSA两种</li><li>rsa：指使用RSA算法</li><li>-f：指定存储密钥的文件名</li><li>-C：表示提供<strong>一个用于识别这个密钥的注释，一般填写邮箱地址，但也可以填入其他内容</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>Git配置邮箱和用户名的目的</p><p>作为一个分布式版本控制系统，远程仓库为了跟踪是谁提交的代码，需要提交这提供身份信息：邮箱和用户名。当然，由于这里的用户名和邮箱完全由提交者设置，所以可能会出现提交者随意填写的情况发生。不过，当这种情况发生时，可以通过一些机制查询出真正的提交者。</p></li><li><p>Git配置的邮箱和用户名和GitHub有什么关系</p><ul><li>账号密码和公钥私钥对只做权限的认证，即判断当前用户或机器是否可以向GitHub中的仓库推送代码。但是这两种认证方式不会记录是由谁把代码推送到GitHub中的，所以使用Git在本地配置的邮箱和用户名作为标记用于记录是谁做的推送操作。即：<ul><li>账号密码和公钥私钥对用于认证，即打开GitHub的大门</li><li>Git配置的邮箱和用户名用于记录是谁向GitHub推送的代码，即记录下是谁在GitHub中做的操作</li></ul></li></ul></li><li><p>Git和GitHub可不可以配置不同的邮箱和用户名</p><p>可以，但最好还是配置相同的邮箱和用户名。正如上面所说，只有这样，GitHub中才能正确的记录你的操作。另外：</p><ul><li>如果Git配置的邮箱是GitHub中存在的邮箱，则commits里显示的是这个邮箱对应的账号</li><li>如果Git配置的邮箱是一个在GitHub里不存在的邮箱，则commits里显示的是Git配置的用户名</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Git技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch中nn.XXX与F.XXX的区别</title>
      <link href="/2023/07/12/PyTorch%E4%B8%ADnn-XXX%E4%B8%8EF-XXX%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/07/12/PyTorch%E4%B8%ADnn-XXX%E4%B8%8EF-XXX%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="nn-XXX与F-XXX"><a href="#nn-XXX与F-XXX" class="headerlink" title="nn.XXX与F.XXX"></a>nn.XXX与F.XXX</h2><p>PyTorch中torch.nn<strong>（以下简写为nn）</strong>中的模块和torch.nn.functional<strong>（以下简写为F）</strong>中的模块都提供了常用的神经网络操作，包括激活函数、损失函数、池化操作等。它们的主要区别如下：</p><ul><li>nn中的模块是以类形式存在的；F中的模块是以函数形式存在的</li><li>nn中的模块是nn.Module的子类，包含可学习参数、可导，在反向传播中可以计算梯度，可以在模型中作为子模块使用；F中的模块是纯函数，没有与之相关联的可学习参数，虽然也可以用于反向传播，但是其梯度需要手动计算</li><li>nn中的模块需要实例化后，将张量作为实例的调用参数；F中的模块直接传递张量作为参数</li><li>nn中的模块可以管理和访问模块的内部参数和状态；F中的函数是纯函数，没有与之相关联的参数或状态，因此无法直接管理和访问函数的内部状态</li></ul><h2 id="nn-Relu与F-relu"><a href="#nn-Relu与F-relu" class="headerlink" title="nn.Relu与F.relu()"></a>nn.Relu与F.relu()</h2><p>以激活函数ReLu为例，在使用激活函数时，有以下两种方式可以使用：</p><pre><code class="python"># 方法一nn.ReLU()# 方法二F.relu(input)</code></pre><p>这两种方法都是使用ReLu激活，但使用的场景不一样。</p><ul><li><p>nn.ReLU是一个类，必须实例化后才能使用，一般在<strong>定义网络层</strong>的时候使用</p><pre><code class="python"># nn.ReLU的常用方法nn.Sequential(            nn.Conv2d(in_channels, out_channels),            nn.ReLU(inplace=True)        )</code></pre></li><li><p>F.relu()是函数调用，一般使用在<strong>foreward()函数</strong>中</p></li><li><p>nn.ReLU只能处理Variable类型的张量；而F.relu()可以处理Tensor和Variable类型的张量</p></li><li><p>nn.ReLU需要额外占用内存用来存储中间结果；而F.relu()则是直接在原张量上进行操作，不需要额外的内存占用</p></li></ul><p>另外：</p><ul><li>当用print()打印输出神经网络时，会输出nn.ReLU()层，而F.relu()是没有输出的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch搭建神经网络</title>
      <link href="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>PyTorch版本：1.12.1</li><li><a href="https://pytorch.org/docs/stable/index.html">PyTorch官方文档</a></li><li><a href="https://pytorch.apachecn.org/#/">PyTorch中文文档</a></li></ul><p>PyTorch中搭建并训练一个神经网络分为以下几步：</p><ol><li>定义神经网络</li><li>定义损失函数以及优化器</li><li>训练：反向传播、梯度下降</li></ol><p>下面以LeNet-5为例，搭建一个卷积神经网络用于手写数字识别。</p><h2 id="1-模型简介——LeNet-5"><a href="#1-模型简介——LeNet-5" class="headerlink" title="1. 模型简介——LeNet-5"></a>1. 模型简介——LeNet-5</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/726791">LeNet-5</a>是一个经典的深度卷积神经网络，由Yann LeCun在1998年提出用于解决手写数字识别问题。该网络是第一个被广泛应用于数字图像识别的神经网络之一，也是深度学习领域的里程碑之一，被认为是卷积神经网络的起源之一。</p><p>如下图所示，LeNet-5的结构是一个7层的卷积神经网络（不含输入层），其中包括2个卷积层、2个下采样层（池化层）、2个全连接层以及输出层。</p><p><img src="/2023/07/12/PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.jpg" alt="1"></p><h3 id="1-1-输入层（Input-layer"><a href="#1-1-输入层（Input-layer" class="headerlink" title="1.1 输入层（Input layer)"></a>1.1 输入层（Input layer)</h3><p>输入层接收大小为 32*32 的灰度手写数字图像，像素灰度值范围为0-255。为了加快训练速度以及提高模型准确性，通常会对输入图像的像素值进行归一化。</p><h3 id="1-2卷积层C1（Convolutional-layer-C1）"><a href="#1-2卷积层C1（Convolutional-layer-C1）" class="headerlink" title="1.2卷积层C1（Convolutional layer C1）"></a>1.2卷积层C1（Convolutional layer C1）</h3><p>卷积层C1含有6个卷积核，每个卷积核的大小为 5*5 ，步长为1，填充为0。卷积层C1产生6个大小为 28*28 的特征图。</p><h3 id="1-3-下采样层S2（Subsampling-layer-S2）"><a href="#1-3-下采样层S2（Subsampling-layer-S2）" class="headerlink" title="1.3 下采样层S2（Subsampling layer S2）"></a>1.3 下采样层S2（Subsampling layer S2）</h3><p>采样层S2采用最大池化（max-pooling）操作，这可以减少特征图的大小从而提高计算效率，并且池化操作对于轻微的位置变化可以保持一定的不变性。池化层每个窗口的大小为 2*2 ，步长为2。池化层S2产生6个大小为 14*14 的特征图。</p><h3 id="1-4-卷积层C3（Convolutional-layer-C3）"><a href="#1-4-卷积层C3（Convolutional-layer-C3）" class="headerlink" title="1.4 卷积层C3（Convolutional layer C3）"></a>1.4 卷积层C3（Convolutional layer C3）</h3><p>卷积层C3包括16个卷积核，每个卷积核的大小为 5*5 ，步长为1，填充为0。卷积层C1产生16个大小为 10*10的特征图。</p><h3 id="1-5-下采样层S4（Subsampling-layer-S4）"><a href="#1-5-下采样层S4（Subsampling-layer-S4）" class="headerlink" title="1.5 下采样层S4（Subsampling layer S4）"></a>1.5 下采样层S4（Subsampling layer S4）</h3><p>下采样层S4采用最大池化操作，每个窗口的大小为 2*2 ，步长为2。池化层S4产生16个大小为 5*5 的特征图。</p><h3 id="1-6-全连接层C5（Fully-connected-layer-C5）"><a href="#1-6-全连接层C5（Fully-connected-layer-C5）" class="headerlink" title="1.6 全连接层C5（Fully connected layer C5）"></a>1.6 全连接层C5（Fully connected layer C5）</h3><p>C5将16个大小为 5*5 的特征图拉成一个长度为400的向量，并通过一个包括120个神经元的全连接层。120是由LeNet-5的设计者根据实验得到的最佳值。</p><h3 id="1-7-全连接层F6（Fully-connected-layer-F6）"><a href="#1-7-全连接层F6（Fully-connected-layer-F6）" class="headerlink" title="1.7 全连接层F6（Fully connected layer F6）"></a>1.7 全连接层F6（Fully connected layer F6）</h3><p>全连接层F6将120个神经元连接到84个神经元。</p><h3 id="1-8-输出层（Output-layer）"><a href="#1-8-输出层（Output-layer）" class="headerlink" title="1.8 输出层（Output layer）"></a>1.8 输出层（Output layer）</h3><p>输出层由10个神经元组成，每个神经元对应0-9的激活值（激活值越大，是该数字的可能性越大）。模型训练时，使用交叉熵损失函数计算输出层与样本真实标签之间的误差，然后通过反向传播算法更新模型的参数（包括卷积核和全连接层）直至模型达到指定效果或者达到指定迭代次数。</p><p><strong>在实际应用中，通常会对LeNet-5进行一些改进，例如增加网络深度、增加卷积核数量、添加正则化等方法，以进一步提高模型的准确性和泛化能力。</strong></p><h2 id="2-数据集简介——MNIST"><a href="#2-数据集简介——MNIST" class="headerlink" title="2. 数据集简介——MNIST"></a>2. 数据集简介——MNIST</h2><p><a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>是一个手写体数字的图片数据集，包含60,000个训练图像和10,000个测试图像，由美国国家标准与技术研究所（National Institute of Standards and Technology (NIST)）发起整理，一共统计了来自250个不同的人手写数字图片，其中50%是高中生，50%来自人口普查局的工作人员。<strong>数据集中的图像都是灰度图像，大小为 28*28 像素，每个像素点的值为 0 到 255 之间的灰度值</strong>。</p><p>使用torchvision中的datasets可自动下载该数据集：</p><pre><code class="python">train_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=True, transform=transforms.ToTensor(), download=True)test_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=False, transform=transforms.ToTensor(), download=True)</code></pre><p>其中：</p><ul><li><p>root表示将数据集存放在当前目录下的’data’文件夹中。</p></li><li><p>train&#x3D;True表示导入的是训练数据；train&#x3D;False表示导入的是测试数据。</p></li><li><p>transform表示对每个数据进行的变化，这里是将其变为Tensor，Tensor是PyTorch中存储数据的主要格式。</p></li><li><p>download表示是否将数据下载到本地。</p></li></ul><h2 id="3-定义神经网络"><a href="#3-定义神经网络" class="headerlink" title="3. 定义神经网络"></a>3. 定义神经网络</h2><p>PyTorch中主要有以下两种方式定义神经网络</p><h3 id="3-1-使用前馈神经网络方式"><a href="#3-1-使用前馈神经网络方式" class="headerlink" title="3.1 使用前馈神经网络方式"></a>3.1 使用前馈神经网络方式</h3><p>这种方法需要<strong>继承torch.nn.Module</strong>并且<strong>实现__init__()和forward()这两个方法</strong>。其中__init__()可以用于做一些初始化工作，比如定义输入数据、隐藏层、激活函数等；forward()是实现前向传播的核心函数，用于定义神经网络的结构和参数，在前向传播的过程中，输入的数据将按照该函数定义的神经网络结构进行计算并得到最终的输出。</p><pre><code class="python">import torch.nn.functional as Ffrom torch import nnclass MyCNN(nn.Module):    def __init__(self, in_channels):        super(MyCNN, self).__init__()        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1)  # 定义卷积核        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # 定义最大池化层        self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(in_features=16 * 4 * 4, out_features=120)  # 定义全连接层        self.fc2 = nn.Linear(in_features=120, out_features=84)        self.fc3 = nn.Linear(in_features=84, out_features=10)    def forward(self, x):        x1 = self.conv1(x)  # 卷积层C1        x2 = F.relu(x1)  # 激活函数        x3 = self.pool1(x2)  # 下采样层S2        x4 = self.conv2(x3)  # 卷积层C3        x5 = F.relu(x4)        x6 = self.pool2(x5)  # 下采样层S4        x7 = x.reshape(x6.shape[0], -1)  # 二维变成一维，以输入到全连接层        x8 = self.fc1(x7)  # 全连接层C5        x9 = F.relu(x8)        x10 = self.fc2(x9)  # 全连接层F6        x11 = F.relu(x10)        x12 = self.fc3(x11)  # 输出层        return x12</code></pre><p>代码解释</p><ul><li><p>__init__()：</p><p>定义了用到的卷积核、池化层以及全连接层，其中：</p><ul><li>nn.Conv2d，定义二维卷积核。in_channels，输入通道数量；out_channels，输出通道数量；kernel_size，卷积核大小；stride，卷积时的步长。</li><li>nn.MaxPool2d，定义二维最大池化层。kernel_size，池化的窗口大小；stride，池化时的步长。</li><li>nn.Linear，定义全连接层。in_features，输入数据的大小；out_features，输出数据的大小。</li></ul></li><li><p>forward()：</p><p>__init__()函数中仅仅是定义了各个层，但并未将它们连接起来搭建出一个神经网络，forward()函数的作用就是搭建一个神经网络，使得输入的数据沿着指定的结构进行前向传播：</p><ul><li>forward除了self之外，还接收一个参数x作为输入数据。</li><li>x &#x3D; self.conv1(x)：输入的x经过卷积计算后得到x1，对应于卷积层C1。</li><li>x2 &#x3D; F.relu(x1) ：对卷积后的数据进行ReLU激活操作。</li><li>x3 &#x3D; self.pool1(x2) ：对数据进行池化，对应于下采样层S2。</li><li>……</li><li>与上面类似，数据依次经过卷积层C3、下采样层S4、全连接层C5、全连接层F6以及输出层，从而使输入x沿着指定的路径得到最终的输出。</li></ul><p><strong>注：</strong></p><ul><li><p>为了更好的展示数据如何沿着神经网络进行前向传播，这里对每一层的输出设置了不同的变量命名，实际应用时，可以将x1~x12都写作x，只要不影响前向传播即可。</p></li><li><p>二维卷积以及池化操作得到的是二维的特则图，但全连接层需要一维的数据，因此需要对数据尺寸进行修改，即：</p><pre><code class="python">x7 = x.reshape(x6.shape[0], -1)</code></pre></li></ul></li></ul><h3 id="3-2-使用序列化方法"><a href="#3-2-使用序列化方法" class="headerlink" title="3.2 使用序列化方法"></a>3.2 使用序列化方法</h3><p>这种方式使用torch.nn.Sequential方式定义模型，将神经网络以序列的方式进行连接，每个层使用前面层计算的输出作为输入，并且在内部会维护层与层之间的权重矩阵和偏置向量。</p><pre><code class="python">from torch import nnin_channels = 1model = nn.Sequential(    nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1),    nn.ReLU(),    nn.MaxPool2d(kernel_size=2, stride=2),    nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1),    nn.ReLU(),    nn.MaxPool2d(kernel_size=2, stride=2),    nn.Flatten(),    nn.Linear(in_features=16 * 4 * 4, out_features=120),    nn.Linear(in_features=120, out_features=84),    nn.Linear(in_features=84, out_features=10))</code></pre><h3 id="3-3总结"><a href="#3-3总结" class="headerlink" title="3.3总结"></a>3.3总结</h3><ol><li>第一种可以更好的根据需要搭建网络结构；</li><li>第二种方式网络以序列的方式搭建网络，不适用于复杂网络；</li><li>对于一些复杂的含有重复层的网络，可将两种方式结合使用。序列化方法定义重复层，然后使用第一种方式根据网络结构进行组装。</li></ol><h2 id="4-定义损失函数以及优化器"><a href="#4-定义损失函数以及优化器" class="headerlink" title="4. 定义损失函数以及优化器"></a>4. 定义损失函数以及优化器</h2><ul><li><p>损失函数</p><p>损失函数用于计算真实值和预测值之间的差异。在<a href="https://pytorch.org/docs/stable/nn.html#loss-functions">PyTorch官方文档</a>中，给出了可用的损失函数列表。</p><p>这里，我们使用交叉熵损失函数<strong>torch.nn.CrossEntropyLoss()<strong>。</strong>该损失函数内部自动加上了Softmax</strong>，用于解决多分类问题，也可用于解决二分类问题。</p></li><li><p>优化器</p><p>优化器根据损失函数求出的损失，对神经网络的参数进行更新。在<a href="https://pytorch.org/docs/stable/optim.html">PyTorch官方文档</a>中，给出了可用的优化器。</p><p>这里，我们使用**torch.optim.Adam()**作为我们的优化器。</p></li></ul><pre><code class="python">from torch import nn, optimcriterion = nn.CrossEntropyLoss()  # 损失函数optimizer = optim.Adam(model.parameters())  # 优化器</code></pre><p>其中：</p><ul><li>model.parameters()是待优化的参数。</li></ul><h2 id="5-训练模型"><a href="#5-训练模型" class="headerlink" title="5.训练模型"></a>5.训练模型</h2><p>模型的训练主要包括3部分：</p><ul><li>前向传播</li><li>反向传播</li><li>梯度下降</li></ul><p>简单的说就是取出数据，放到模型里面跑一次得到预测值，计算与真实值之间的损失，然后计算梯度，根据梯度更新一次网络。</p><p>代码实现如下：</p><pre><code class="python">device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)model = MyCNN(1).to(device)  # 加载模型到设备num_epochs = 100for epoch in range(num_epochs):    for batch_idx, (data, label) in enumerate(train_loader):        data = data.to(device=device)  # 加载数据到设备        label = label.to(device=device)        # 前向传播        pre = model(data)        loss = criterion(pre, label)        # 反向传播        optimizer.zero_grad()        loss.backward()        # 梯度下降        optimizer.step()</code></pre><p>其中：</p><ul><li><p>torch.device(‘cuda’ if torch.cuda.is_available() else ‘cpu’)：选择使用GPU或者CPU训练，若电脑有GPU且配置正确，则使用GPU训练，否则使用CPU训练（模型和数据必须都放在GPU或者CPU上）。</p></li><li><p>for epoch in range(num_epochs)：模型训练次数。</p></li><li><p>for batch_idx, (data, label) in enumerate(train_loader)：mini-batch对数据进行小批量训练。</p></li><li><p>前向传播：</p><ul><li>pre &#x3D; model(data)：将数据放入模型中训练。</li><li>loss &#x3D; criterion(pre, label)：通过损失函数得到本次训练的损失。</li></ul></li><li><p>反向传播：</p><ul><li>optimizer.zero_grad()：将梯度归零。训练时通常使用mini-batch方法，<strong>如果不将梯度清零的话，梯度会与上一个batch的梯度相关，因此该函数要写在反向传播和梯度下降之前</strong>。</li><li>loss.backward()：反向传播。计算得到每个参数的梯度。</li></ul></li><li><p>梯度下降</p><p>optimizer.step()：执行一次优化步骤，对参数进行更新。注意：optimizer.step()只负责通过梯度下降对参数进行优化，并不负责产生梯度，梯度是loss.backward()方法产生的。</p></li></ul><h2 id="6-测试模型"><a href="#6-测试模型" class="headerlink" title="6. 测试模型"></a>6. 测试模型</h2><p>模型训练完毕后，可以使用测试集对模型进行测试：</p><pre><code class="python">loss = 0with torch.no_grad():  # 关闭梯度计算    model.eval()  # 评估模式    for batch_idx, (data, label) in enumerate(test_loader):        data = data.to(device=device)        label = label.to(device=device)        pre = model(data)        loss += criterion(pre, label).item()model.train()  # 训练模式loss = loss / len(test_loader.dataset)</code></pre><p>其中：</p><ul><li><p>with torch.no_grad()：关闭梯度计算。在训练模型时，需要计算根据反向传播计算梯度以更新参数，但在对验证集或者测试集进行预测时，并不需要更新参数，因此也就不需要计算梯度。因此，为了避免浪费计算资源，在模型评估时最后关闭梯度计算。</p></li><li><p>model.eval()：将模型切换到评估模式。在神经网络中，出于防止过拟合等目的，一般会加入Dropout和Batch Normalization层，在模型训练阶段，根据输入数据的变化，这些层的参数也会发生变化。<strong>在评估模式下，Dropout层会让所有的网络节点都生效，而Batch Normalization层会停止计算和更新均值和方差，直接使用在训练阶段已经学出的均值和方差。</strong></p></li><li><p>model.train()：将模型切换到训练模式。此时Dropout层使网络中的节点以一定概率失效，Batch Normalization层根据输入的数据更新均值和方差。<strong>在将模型切换到评估模式之后，在下一次训练之前必须再切换到训练模式。</strong></p></li><li><p>注意with torch.no_grad()和model.eval()的区别：</p><p>with torch.no_grad()关闭的是梯度计算，和神经网络整体有关；而model.eval()和梯度没有关系，只和Dropout和Batch Normalization这两层有关系。</p></li></ul><h2 id="7-整体代码"><a href="#7-整体代码" class="headerlink" title="7. 整体代码"></a>7. 整体代码</h2><p>以下是最终的代码（使用前馈神经网络的方式定义神经网络）。由于这里仅仅是为了介绍如何搭建一个模型，另外出于篇幅考虑，对于一些细节方面未做具体改进，主要包括以下几点：</p><ul><li>除了训练集和测试集之外，还可以使用验证集评估模型性能以设置早停</li><li>为了得到更好的模型性能，一般会对数据进行归一化</li></ul><pre><code class="python">import torchimport torch.nn as nnimport torch.nn.functional as Fimport torchvisionfrom torch import optimfrom torch.utils.data import DataLoaderfrom torchvision import transformsclass MyCNN(nn.Module):    def __init__(self, in_channels):        super(MyCNN, self).__init__()        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=6, kernel_size=5, stride=1)  # 定义卷积核        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # 定义最大池化层        self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5, stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(in_features=16 * 4 * 4, out_features=120)  # 定义全连接层        self.fc2 = nn.Linear(in_features=120, out_features=84)        self.fc3 = nn.Linear(in_features=84, out_features=10)    def forward(self, x):        x = self.conv1(x)  # 卷积层C1        x = F.relu(x)  # 激活函数        x = self.pool1(x)  # 下采样层S2        x = self.conv2(x)  # 卷积层C3        x = F.relu(x)        x = self.pool2(x)  # 下采样层S4        x = x.reshape(x.shape[0], -1)  # 二维变成一维，以输入到全连接层        x = self.fc1(x)  # 全连接层C5        x = F.relu(x)        x = self.fc2(x)  # 全连接层F6        x = F.relu(x)        x = self.fc3(x)  # 输出层        return xdef train(model, criterion, optimizer, train_loader, device, num_epochs=200):    for epoch in range(num_epochs):        for batch_idx, (data, label) in enumerate(train_loader):            data = data.to(device=device)  # 加载数据到设备            label = label.to(device=device)            # 前向传播            pre = model(data)            loss = criterion(pre, label)            # 反向传播            optimizer.zero_grad()            loss.backward()            # 梯度下降            optimizer.step()def test(model, criterion, test_loader, device):    loss = 0    with torch.no_grad():  # 关闭梯度计算        model.eval()  # 评估模式        for batch_idx, (data, label) in enumerate(test_loader):            data = data.to(device=device)            label = label.to(device=device)            pre = model(data)            loss += criterion(pre, label).item()    model.train()  # 训练模式    loss = loss / len(test_loader.dataset)    return lossdef main():    batch_size = 4    num_epochs = 200    train_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=True, transform=transforms.ToTensor(),                                               download=True)  # 下载数据集    test_dataset = torchvision.datasets.MNIST(root=&quot;data/&quot;, train=False, transform=transforms.ToTensor(), download=True)    train_loader = DataLoader(dataset=train_dataset, batch_size=batch_size,                              shuffle=True)  # 将数据集(Dataset)自动分成一个个的Batch,以用于批处理    test_loader = DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=True)    device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)  # 选择加载数据的设备，GPU或者CPU    model = MyCNN(1).to(device)  # 模型和数据应加载到同一种设备上    criterion = nn.CrossEntropyLoss()  # 损失函数    optimizer = optim.Adam(model.parameters())  # 优化器    train(model, criterion, optimizer, train_loader, device, num_epochs)    print(test(model, criterion, test_loader, device))if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt环境安装</title>
      <link href="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="下载Qt"><a href="#下载Qt" class="headerlink" title="下载Qt"></a>下载Qt</h2><h3 id="Qt资源下载地址"><a href="#Qt资源下载地址" class="headerlink" title="Qt资源下载地址"></a>Qt资源下载地址</h3><p> <a href="https://download.qt.io/archive">https://download.qt.io/archive</a></p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1.png" alt="1"></p><p>其中：</p><ul><li><p>qtcreator文件夹下存放的是不同版本的qtcreator，Qt Creator是一个用于Qt开发的轻量级跨平台集成开发环境</p></li><li><p>qt文件夹下存放的是不同版本的qt，Qt是一个跨平台的C++应用程序开发框架</p></li></ul><p>Qt从5.0版本开始自带Qt Creator，因此，若安装5.0以前版本的Qt需要再单独安装Qt Creator。我安装的是5.12.12，自带Qt Creator，因此不需要再单独安装。</p><h3 id="Qt5-12-12下载地址"><a href="#Qt5-12-12下载地址" class="headerlink" title="Qt5.12.12下载地址"></a>Qt5.12.12下载地址</h3><p><a href="https://download.qt.io/archive/qt/5.12/5.12.12](https://download.qt.io/archive/qt/5.12/5.12.12)">https://download.qt.io/archive/qt/5.12/5.12.12](https://download.qt.io/archive/qt/5.12/5.12.12)</a></p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/2.png" alt="2"></p><p>其中：</p><ul><li>.exe是Windows平台下的安装包</li><li>.dmg是Mac平台下的安装包</li><li>.run是Linux平台下的安装包</li></ul><p>点击对应平台下的安装包下载即可。若网页访问速度慢，可访问国内镜像网站：</p><ul><li><p><a href="https://mirrors.ustc.edu.cn/qtproject/archive">中国科学技术大学Qt镜像</a></p></li><li><p><a href="https://mirrors.sjtug.sjtu.edu.cn/qt/archive">上海交通大学Qt镜像</a></p></li></ul><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>以Windows平台下安装Qt 5.12.12为例，打开安装包：</p><ol><li><p>填写账号</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/3.png" alt="3"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/4.png" alt="4"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/5.png" alt="5"></p></li><li><p>选择安装路径（不要带中文）</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/6.png" alt="6"></p></li><li><p>选择组件，其中：</p><ul><li><p>MSVC：Microsoft Visual C++ Compiler，微软的VC编译器</p></li><li><p>MinGW：Minimalist GNU for Window，将GCC编译器和GNU Binutils移植到Windows平台下的产物，它是一些头文件和使用 GNU 工具集导入库的集合，允许用户在没有第三方 dll 的情况下生成本地的 Windows 程序</p><p><strong><font color="#0000dd">注：</font></strong></p><p><strong><font color="#0000dd">MSVC 和 MingGW 都是很好用的工具，但兼容并不好，比如某项目使用了 MingGW 编译，那么它所链接的库也必须是 MingGW 编译而成。 一般来说，如果仅在 Windows 平台开发，选择 MSVC，可以使用大量的第三方库；如果有跨平台需求，选择 MingGW。</font></strong></p><p><strong><font color="#0000dd">由于两个版本的Qt配置方式完全不同。因此在网上搜配置方法的时候，要加上MSVC或者MinGW这样的关键字搜索。</font></strong></p></li><li><p>UWP：属于 MSVC 编译器生成的 Qt 库，用于开发通用 Windows 平台的应用程序</p></li><li><p>Android：用于 Android 应用开发的 Qt 库</p></li><li><p>Sources：源码包，添加后可以使用源码调试功能</p></li><li><p>Qt Charts：二维图表模块，用于绘制柱状图、饼图、曲线图等常用二维图表</p></li><li><p>Qt Data Visualization：三维数据图表模块，用于数据的三维显示，如散点的三维空间分布、三维曲面等。</p></li></ul><ul><li>Qt Purchasing：用于处理 Android、iOS 和 macOS 上的应用内购买的跨平台 API</li><li>Qt Virtual Keyboard：Qt Quick 虚拟键盘</li><li>Qt WebEngine：集成了Google Chromium Web，充分利用了整个 Qt 图形堆栈集成，允许原生 Qt 控件与 Web 内容和 OpenGL 着色器的无缝混合和叠加</li><li>Qt Network Authorization：Qt 网络授权是一个附加库，它使 Qt 应用程序能够使用不同的 Web 身份验证系统</li><li>Qt WebGL Streaming Plugin：一个 Qt Platform Abstraction 插件，它通过网络将 Qt Quick &amp; Qt OpenGL 应用程序流式传输到支持 WebGL 的浏览器。</li><li><del>Qt Script (Deprecated)：脚本模块，已弃用</del></li></ul><p>Tools 节点下的工具：</p><ul><li><p>Qt Creator：Qt5.0版本以上集成的轻量级跨平台集成开发环境（5.0以下需要单独安装）</p></li><li><p>CDB Debugger Support：控制台调试器，是 MSVC 在 Qt 的原生调试器，由于MSVC 只有编译器，如果选择它，则需要勾选；如选择 MinGW 则不需要，MinGW 中有 GDB调试器</p></li><li><p>MingGW ：这里的 MingGW 是用来交叉编译的，在一个平台上生成另一个平台上的可执行代码</p></li><li><p>Strawberry Perl：Perl 语言工具</p><p>根据个人需要，我选择了以下组件（若不确定选哪个，可以全选）</p></li></ul><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/7.png" alt="7"></p></li><li><p>许可协议</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/8.png" alt="8"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/9.png" alt="9"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/10.png" alt="10"></p></li><li><p>等待安装完成</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/11.png" alt="11"></p></li><li><p>安装完成</p></li></ol><p>   <img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/12.png" alt="12"></p><h2 id="创建快捷方式"><a href="#创建快捷方式" class="headerlink" title="创建快捷方式"></a>创建快捷方式</h2><p>安装好后的Qt Creator未在桌面创建快捷方式，可以使用以下方式创建：</p><ol><li><p>打开“开始菜单”，找到安装好的“Qt Creator”，然后“右键”-&gt;“更多”-&gt;“打开文件位置”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/13.jpg" alt="13"></p></li><li><p>在“Qt Creator”上右键，然后”发送到”-&gt;“桌面快捷方式”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/14.jpg" alt="14"></p></li></ol><h2 id="“Hello-World”之第一个Qt应用"><a href="#“Hello-World”之第一个Qt应用" class="headerlink" title="“Hello World”之第一个Qt应用"></a>“Hello World”之第一个Qt应用</h2><ol><li><p>打开Qt Creator，“文件”-&gt;“新建文件或项目”</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/15.png" alt="15"></p></li><li><p>选择模板，部分选项如下：</p><ul><li>Qt Widgets Application，支持桌面平台的GUI 界面应用程序</li><li>Qt Console Application，控制台应用程序，无 GUI 界面</li><li>Application（Qt Quick），创建可部署的 Qt Quick 2 应用程序。Qt Quick 是 Qt 支持的一套 GUI 开发架构，其界面设计采用 QML 语言，程序架构采用 C++ 语言。利用 Qt Quick 可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计</li></ul><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/16.png" alt="16"></p></li><li><p>工程路径，注意路径及工程名字不能含有空格或中文</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/17.png" alt="17"></p></li><li><p>选择构建系统，其中：</p><ul><li>qmake，为 Qt 量身打造的，使用起来非常方便</li><li>cmake，使用上不如qmake简单直接，但复杂换来的是强大的功能</li><li>Qbs ，号称下一代构建工具</li></ul><p>对简单的Qt工程，采用 qmake；对复杂度超过 qmake 处理能力的，采用 cmake。这里我选择qmake。</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/18.png" alt="18"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/19.png" alt="19"></p></li><li><p>翻译文件，用于国际化，暂时不用设置，默认即可</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/20.png" alt="20"></p></li><li><p>选择构建套件，这里我选择MinGW 64-bit，不同构建套件的区别见上面“安装Qt”中的“选择组件”步骤</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/21.png" alt="21"></p></li><li><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/22.png" alt="22"></p></li><li><p>打开 .ui 文件</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/23.png" alt="23"></p></li><li><p>在“Display Widgets”下拖一个“Label”到中间，在其中填入“Hello World”，并在右侧修改宽度</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/24.png" alt="24"></p></li><li><p>点击左下角的“绿色三角形”运行程序</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/25.png" alt="25"></p></li><li><p>程序运行成果，显示GUI界面</p><p><img src="/2023/07/08/Qt%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/26.png" alt="26"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离思五首·其四</title>
      <link href="/2023/07/08/%E7%A6%BB%E6%80%9D%E4%BA%94%E9%A6%96%C2%B7%E5%85%B6%E5%9B%9B/"/>
      <url>/2023/07/08/%E7%A6%BB%E6%80%9D%E4%BA%94%E9%A6%96%C2%B7%E5%85%B6%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<center>离思五首·其四</center><p align="right">元稹【唐】</p><hr><center>曾经沧海难为水，</center><center>除却巫山不是云。</center><center>取次花丛懒回顾，</center><center>半缘修道半缘君。</center><p>第一次读到这首诗的时候，因为没读懂“曾经”两个字，所以对前两句半知半解，只觉得后两句写得很妙。后来某一天突然醒悟过来，“曾经”是两个词：曾经经过，这才体会到前两句的韵味。特别是最近想起来这首诗，更是咂摸出一番新的滋味。<br>“领略过沧海的波涛汹涌，别处的水就不值得看了；沉醉过巫山云景的梦幻飘渺，别处的云都不能被叫作云景了；即使从万花丛中走过，也懒得看一眼”如果只读到前三句，可能会是一头雾水，这到底想表达什么意思？为什么别处的水不值得看？为什么别处的云不能被叫作云景？为什么不看一眼身边的花？正当疑问之时，最后一句点名原因“一半是因为我在修道，另一半是因为你呀！”<br>个人认为，这首诗除了前两句的比喻极其绝妙之外，整体结构上也是极具深意的，可以说是含蓄美的极致体现。前三句不明说对你的爱慕，只是说沧海、说巫山云雨、说万花丛，直到最后一句点睛之笔才知道这哪是在说什么沧海云雨，这句句都是在说心上人啊！哪怕到了最后点名原因了，还要再说一句“半缘修道”，可是真的有一半原因是修道吗？恐怕未必，或者说“修道”本身也是“缘君”。这种写法， 层层递进，先是三句描写自己心态的句子，然后自然而然的说出自己为何这样，虽然整体上感觉不到太大的感情波动，但却将思恋之情委婉而又淋漓尽致的表现了出来。<br>如果换成现在，或许就是这样吧：<br>今天的晚霞好美，像一条红绸带从天边垂下；晚饭也很香，炸鸡腿外焦里嫩，咬一口嘎吱响。<br>但是我不想去看晚霞也没心思吃饭。<br>为什么？<br>因为最近很忙很累，嗯，更重要的是，好久不见想你了……</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
            <tag> 唐 </tag>
            
            <tag> 元稹 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
